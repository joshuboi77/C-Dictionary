// Auto-generated from C_Dictionary.md. Do not edit manually.
module.exports = [
  { token: '!', type: 'identifier', description: 'Logical NOT. Converts nonzero to 0 and 0 to 1.', example: 'int t = !0; // 1' },
  { token: '!=', type: 'identifier', description: 'Inequality comparison.', example: 'int b = (2 != 3); // 1' },
  { token: '#', type: 'identifier', description: 'Preprocessor stringizing operator inside macros: converts a macro parameter to a string literal.', example: '#define S(x) #x\n// S(hello) -> "hello"' },
  { token: '##', type: 'identifier', description: 'Preprocessor token pasting operator: concatenates tokens in macro expansion.', example: '#define CAT(a,b) a##b\n// CAT(var, 1) -> var1' },
  { token: '%', type: 'identifier', description: 'Remainder after integer division. Behavior is defined so that `(a / b) * b + (a % b) == a` when `b != 0`.', example: 'int r = 7 % 3; // 1' },
  { token: '%:', type: 'identifier', description: 'Digraph for `#` in source code.', example: '%:define N 10' },
  { token: '%:%:', type: 'identifier', description: 'Digraph for `##` in source code.', example: '#define CAT(a,b) a %:%: b  // token pasting' },
  { token: '%=', type: 'identifier', description: 'Remainder assignment.', example: 'x %= 3;  // x = x % 3' },
  { token: '%>', type: 'identifier', description: 'Digraph for `}` in source code.', example: 'int main()<% return 0; %>' },
  { token: '&', type: 'identifier', description: 'Bitwise AND (binary) and address-of (unary). Unary `&` yields the address of its operand.', example: 'int a = 6, b = 3; int c = a & b; // 2\nint *p = &a; // address-of' },
  { token: '&&', type: 'identifier', description: 'Logical AND with short-circuit evaluation. Evaluates right operand only if left is nonzero.', example: 'if (ptr && *ptr == \'\\0\') { /* safe only if ptr != NULL */ }' },
  { token: '&=', type: 'identifier', description: 'Bitwise AND assignment.', example: 'x &= 0xFF;' },
  { token: '( )', type: 'identifier', description: 'Parentheses for grouping expressions and for function calls.', example: 'int y = (2 + 3) * 4;  // 20\nint f(int);\nint r = f(42);' },
  { token: '*', type: 'identifier', description: 'Multiplication (binary) and indirection/dereference (unary).', example: 'int prod = 6 * 7; // 42\nint *p = &prod; int v = *p; // dereference' },
  { token: '*=', type: 'identifier', description: 'Multiplication assignment.', example: 'x *= 3;  // x = x * 3' },
  { token: '+', type: 'identifier', description: 'Addition (binary) and unary plus (no effect on value). Pointer arithmetic is scaled by pointed-to type size.', example: 'int s = 1 + 2; // 3' },
  { token: '++', type: 'identifier', description: 'Increment operator. Prefix form yields the incremented value; postfix yields the original value.', example: 'int i = 1;\nint a = ++i; // i=2, a=2\nint b = i++; // i=3, b=2' },
  { token: '+=', type: 'identifier', description: 'Addition assignment.', example: 'x += 5;  // x = x + 5' },
  { token: ',', type: 'identifier', description: 'Comma operator evaluates left expression, discards the value, then evaluates and yields the right expression.', example: 'int y = (x = 1, x + 2); // y = 3' },
  { token: '-', type: 'identifier', description: 'Subtraction (binary) and unary negation. Pointer subtraction yields element count difference for pointers into the same array.', example: 'int d = 5 - 2; // 3' },
  { token: '--', type: 'identifier', description: 'Decrement operator. Prefix form yields the decremented value; postfix yields the original value.', example: 'int i = 2;\nint a = --i; // i=1, a=1\nint b = i--; // i=0, b=1' },
  { token: '-=', type: 'identifier', description: 'Subtraction assignment.', example: 'x -= 2;  // x = x - 2' },
  { token: '->', type: 'identifier', description: 'Member access through a pointer to a structure/union; `p->m` is `(*p).m`.', example: 'struct P { int x; } p = {3};\nstruct P *pp = &p;\nint x = pp->x;  // 3' },
  { token: '.', type: 'identifier', description: 'Member access operator for structures/unions via an lvalue object.', example: 'struct P { int x, y; } p = {1,2};\nint x = p.x;' },
  { token: '...', type: 'identifier', description: 'Variadic parameter marker in function declarators and prototypes.', example: 'int printf(const char *fmt, ...);' },
  { token: '/', type: 'identifier', description: 'Division. Integer division truncates toward zero; division by zero is undefined.', example: 'int q = 7 / 3; // 2' },
  { token: '/=', type: 'identifier', description: 'Division assignment.', example: 'x /= 2;  // x = x / 2' },
  { token: ':', type: 'identifier', description: 'Used in the conditional operator `?:` and to introduce `case` labels and bit-field widths.', example: 'switch (x) { case 1: /* ... */ break; }\nstruct S { unsigned f:3; };' },
  { token: ':>', type: 'identifier', description: 'Digraph for `]` in source code.', example: 'int a<:3:> = {1,2,3};' },
  { token: ';', type: 'identifier', description: 'Statement terminator; also forms the null statement when used alone.', example: 'while (getchar() != \'\\n\') ;  // null body' },
  { token: '<', type: 'identifier', description: 'Less-than relational operator.', example: 'int b = (2 < 3); // 1' },
  { token: '<%', type: 'identifier', description: 'Digraph for `{` in source code.', example: 'int main()<% return 0; %>' },
  { token: '<:', type: 'identifier', description: 'Digraph for `[` in source code.', example: 'int a<:3:> = {1,2,3}; // same as int a[3] = {...}' },
  { token: '<<', type: 'identifier', description: 'Left shift. Shifts bits left; shifting into/sign on signed types is implementation-defined or undefined—prefer unsigned.', example: 'unsigned x = 1u << 3; // 8' },
  { token: '<<=', type: 'identifier', description: 'Left shift assignment.', example: 'x <<= 1; // x = x << 1' },
  { token: '<=', type: 'identifier', description: 'Less-than-or-equal relational operator.', example: 'int b = (2 <= 2); // 1' },
  { token: '=', type: 'identifier', description: 'Simple assignment; stores right-hand value into left-hand lvalue.', example: 'int x; x = 10;' },
  { token: '==', type: 'identifier', description: 'Equality comparison. Compares values after usual conversions.', example: 'int b = (2 + 2 == 4); // 1' },
  { token: '>', type: 'identifier', description: 'Greater-than relational operator.', example: 'int b = (3 > 2); // 1' },
  { token: '>=', type: 'identifier', description: 'Greater-than-or-equal relational operator.', example: 'int b = (3 >= 2); // 1' },
  { token: '>>', type: 'identifier', description: 'Right shift. On unsigned, logical shift; on signed, arithmetic vs logical is implementation-defined.', example: 'unsigned x = 8u >> 1; // 4' },
  { token: '>>=', type: 'identifier', description: 'Right shift assignment.', example: 'x >>= 2; // x = x >> 2' },
  { token: '?', type: 'identifier', description: 'Part of the conditional operator `?:` used as `cond ? expr1 : expr2`. Ternary operator selects between two expressions based on `cond`.', example: 'int max = (a > b) ? a : b;' },
  { token: '[ ]', type: 'identifier', description: 'Array subscript operator. For `a[b]`, computes `*(a + b)`. Behavior is undefined if the computed address is out of bounds.', example: 'int a[3] = {1,2,3};\nint x = a[1];  // 2' },
  { token: '^', type: 'identifier', description: 'Bitwise XOR (exclusive OR).', example: 'int r = 5 ^ 3; // 6' },
  { token: '^=', type: 'identifier', description: 'Bitwise XOR assignment.', example: 'x ^= 1;' },
  { token: '_Alignas', type: 'identifier', description: 'Specifies the alignment requirement of an object or member (may increase, not decrease, alignment). See `<stdalign.h>` for standard alignment macros.', example: '_Alignas(16) unsigned char buf[64];' },
  { token: '_Alignof', type: 'identifier', description: 'Yields the alignment requirement (in bytes) of a type; result type is `size_t`.', example: 'size_t a = _Alignof(double);' },
  { token: '_Atomic', type: 'identifier', description: 'Type qualifier/specifier for atomic types. Use `_Atomic(T)` or `T _Atomic` with `<stdatomic.h>` operations to perform lock-free or atomic accesses.', example: '#include <stdatomic.h>\n_Atomic int counter = 0;' },
  { token: '_BitInt', type: 'identifier', description: 'Bit-precise integer type introduced in C23: `_BitInt(N)` and `unsigned _BitInt(N)` provide integers with exactly `N` value bits (where supported by the implementation).', example: 'unsigned _BitInt(17) x = 0u;' },
  { token: '_Bool', type: 'identifier', description: 'Boolean type with values 0 and 1. Include `<stdbool.h>` to use the aliases `bool`, `true`, and `false`.', example: '#include <stdbool.h>\nbool ok = true;' },
  { token: '_Complex', type: 'identifier', description: 'Complex number type qualifier introduced in C99. Use with a real floating type (e.g., `double _Complex`). Operations and helpers are provided by `<complex.h>`.', example: '#include <complex.h>\ndouble _Complex z = 1.0 + 2.0 * I;\ndouble r = creal(z), im = cimag(z);' },
  { token: '_Complex_I', type: 'identifier', description: '', example: '#include <complex.h>\ndouble complex z = 3.0 + 4.0*_Complex_I; // z == 3 + 4i' },
  { token: '_Generic', type: 'identifier', description: 'C11 compile-time generic selection that chooses an expression based on the type of a controlling expression. Useful for type-generic macros.', example: '#define type_name(x) _Generic((x), \\\n    int: "int", \\\n    double: "double", \\\n    default: "other")' },
  { token: '_I', type: 'identifier', description: '', example: '#include <complex.h>\ndouble complex z = 1.0 + 2.0*_I; // z == 1 + 2i' },
  { token: '_Imaginary', type: 'identifier', description: 'Imaginary-only floating type qualifier from C99. Rarely implemented and seldom used; `<complex.h>` complex types are generally preferred.', example: 'double _Imaginary y = 2.0 * I;  // if supported' },
  { token: '_Noreturn', type: 'identifier', description: 'Function specifier indicating that a function does not return to its caller. Typically used on functions that terminate the program or never return.', example: '#include <stdlib.h>\n_Noreturn void die(void) { exit(1); }' },
  { token: '_Static_assert', type: 'identifier', description: 'C11 compile-time assertion. First argument is a constant expression; second is a string literal message shown on failure.', example: '_Static_assert(sizeof(void*) >= 4, "Pointer too small");' },
  { token: '_Thread_local', type: 'identifier', description: 'Specifies thread storage duration: each thread has its own instance initialized at thread start. Use with `static` or `extern` as needed. Deprecated in C23 in favor of `thread_local`.', example: '_Thread_local int tls_counter;' },
  { token: 'abort', type: 'identifier', description: 'Abnormal process termination. Raises `SIGABRT`; does not call `atexit` handlers.', example: '#include <stdlib.h>\nvoid fatal(void) { abort(); }' },
  { token: 'abs', type: 'identifier', description: 'Returns absolute value of an `int`.', example: '#include <stdlib.h>\nint m = abs(-42); // 42' },
  { token: 'acos', type: 'identifier', description: 'Arc cosine of a floating-point value (in radians). Domain: [-1, 1].', example: '#include <math.h>\ndouble x = acos(1.0); // 0.0' },
  { token: 'acosf', type: 'identifier', description: '`float` version of `acos`.', example: '#include <math.h>\nfloat x = acosf(0.0f);' },
  { token: 'acosh', type: 'identifier', description: 'Inverse hyperbolic cosine. Domain: x >= 1.', example: '#include <math.h>\ndouble y = acosh(1.0); // 0.0' },
  { token: 'acoshf', type: 'identifier', description: '`float` version of `acosh`.', example: '#include <math.h>\nfloat y = acoshf(1.0f);' },
  { token: 'acoshl', type: 'identifier', description: '`long double` version of `acosh`.', example: '#include <math.h>\nlong double y = acoshl(1.0L);' },
  { token: 'acosl', type: 'identifier', description: '`long double` version of `acos`.', example: '#include <math.h>\nlong double x = acosl(1.0L);' },
  { token: 'aligned_alloc', type: 'identifier', description: 'Allocates memory with the specified alignment. Size must be a multiple of alignment; alignment must be a power of two and multiple of `sizeof(void*)`.', example: '#include <stdlib.h>\nvoid *p = aligned_alloc(16, 64);' },
  { token: 'asctime', type: 'identifier', description: 'Converts `struct tm` to a fixed-format string. Not thread-safe; consider `asctime_r` where available.', example: '#include <time.h>\nchar *s = asctime(gmtime(&(time_t){0}));' },
  { token: 'asin', type: 'identifier', description: 'Arc sine (radians). Domain: [-1, 1].', example: '#include <math.h>\ndouble v = asin(0.0);' },
  { token: 'asinf', type: 'identifier', description: '`float` version of `asin`.', example: '#include <math.h>\nfloat v = asinf(0.0f);' },
  { token: 'asinh', type: 'identifier', description: 'Inverse hyperbolic sine.', example: '#include <math.h>\ndouble v = asinh(0.0);' },
  { token: 'asinhf', type: 'identifier', description: '`float` version of `asinh`.', example: '#include <math.h>\nfloat v = asinhf(0.0f);' },
  { token: 'asinhl', type: 'identifier', description: '`long double` version of `asinh`.', example: '#include <math.h>\nlong double v = asinhl(0.0L);' },
  { token: 'asinl', type: 'identifier', description: '`long double` version of `asin`.', example: '#include <math.h>\nlong double v = asinl(0.5L);' },
  { token: 'assert', type: 'identifier', description: 'Diagnostic macro that aborts the program if its condition is false (disabled if `NDEBUG` is defined).', example: '#include <assert.h>\nassert(sizeof(int) >= 2);' },
  { token: 'atan', type: 'identifier', description: 'Arc tangent (radians). Range: (-pi/2, pi/2).', example: '#include <math.h>\ndouble a = atan(1.0);' },
  { token: 'atan2', type: 'identifier', description: 'Arc tangent of `y/x` using signs to determine the correct quadrant. Returns angle in radians.', example: '#include <math.h>\ndouble a = atan2(1.0, 1.0);' },
  { token: 'atan2f', type: 'identifier', description: '`float` version of `atan2`.', example: '#include <math.h>\nfloat a = atan2f(1.0f, 1.0f);' },
  { token: 'atan2l', type: 'identifier', description: '`long double` version of `atan2`.', example: '#include <math.h>\nlong double a = atan2l(1.0L, 1.0L);' },
  { token: 'atanf', type: 'identifier', description: '`float` version of `atan`.', example: '#include <math.h>\nfloat a = atanf(1.0f);' },
  { token: 'atanh', type: 'identifier', description: 'Inverse hyperbolic tangent. Domain: (-1, 1).', example: '#include <math.h>\ndouble t = atanh(0.5);' },
  { token: 'atanhf', type: 'identifier', description: '`float` version of `atanh`.', example: '#include <math.h>\nfloat t = atanhf(0.5f);' },
  { token: 'atanhl', type: 'identifier', description: '`long double` version of `atanh`.', example: '#include <math.h>\nlong double t = atanhl(0.5L);' },
  { token: 'atanl', type: 'identifier', description: 'Arc tangent of a `long double` value (radians). Range: (-pi/2, pi/2).', example: '#include <math.h>\nlong double r = atanl(0.5L);' },
  { token: 'atexit', type: 'identifier', description: 'Registers a function to be called at normal program termination (via `return` from `main` or `exit`). Called in reverse registration order.', example: '#include <stdlib.h>\nstatic void on_exit(void) { /* cleanup */ }\nint main(void) { atexit(on_exit); return 0; }' },
  { token: 'atof', type: 'identifier', description: 'Converts a C string to `double`. No error reporting on overflow/underflow; prefer `strtod` for robust parsing.', example: '#include <stdlib.h>\ndouble v = atof("3.14");' },
  { token: 'atoi', type: 'identifier', description: 'Converts a C string to `int`. No error reporting; prefer `strtol` for robust parsing.', example: '#include <stdlib.h>\nint n = atoi("42");' },
  { token: 'atol', type: 'identifier', description: 'Converts a C string to `long`. No error reporting; prefer `strtol`.', example: '#include <stdlib.h>\nlong n = atol("123456");' },
  { token: 'atoll', type: 'identifier', description: 'Converts a C string to `long long`. No error reporting; prefer `strtoll`.', example: '#include <stdlib.h>\nlong long n = atoll("123456789");' },
  { token: 'auto', type: 'identifier', description: 'Storage class specifier for automatic variables (block scope, automatic storage duration). Local variables declared inside a block are automatic; storage is allocated on entry and released on exit. Because non-static locals are automatic by default, writing `auto` is redundant in C.', example: 'void f(void) {\n    auto int x = 10;  // equivalent to: int x = 10;\n}' },
  { token: 'break', type: 'identifier', description: 'Immediately terminates the nearest enclosing `switch`, `for`, `while`, or `do` loop and transfers control to the statement following it.', example: 'for (int i = 0; i < 10; i++) {\n    if (i == 5) {\n        break; // exits the loop when i is 5\n    }\n}' },
  { token: 'bsearch', type: 'identifier', description: 'Binary search in a sorted array. Returns a pointer to a matching element or `NULL`.', example: '#include <stdlib.h>\nint cmp(const void *a, const void *b) { return (*(const int*)a - *(const int*)b); }\nint arr[] = {1,2,3,4,5};\nint key = 3; int *found = bsearch(&key, arr, 5, sizeof(int), cmp);' },
  { token: 'btowc', type: 'identifier', description: 'Converts a single-byte character to wide character using current locale. Returns `WEOF` on failure or if `c` is `EOF`.', example: '#include <wchar.h>\nwint_t wc = btowc(\'A\');' },
  { token: 'cabs', type: 'identifier', description: 'Magnitude (absolute value) of a `double _Complex` number.', example: '#include <complex.h>\ndouble _Complex z = 3.0 + 4.0*I; double m = cabs(z); // 5.0' },
  { token: 'cabsf', type: 'identifier', description: '`float _Complex` version of `cabs`.', example: '#include <complex.h>\nfloat _Complex z = 1.0f + 2.0f*I; float m = cabsf(z);' },
  { token: 'cabsl', type: 'identifier', description: '`long double _Complex` version of `cabs`.', example: '#include <complex.h>\nlong double _Complex z = 1.0L + 1.0L*I; long double m = cabsl(z);' },
  { token: 'cacos', type: 'identifier', description: 'Complex arc cosine of a `double _Complex` argument (radians).', example: '#include <complex.h>\ndouble _Complex z = 1.0 + 0.0*I; double _Complex w = cacos(z);' },
  { token: 'cacosf', type: 'identifier', description: '`float _Complex` version of `cacos`.', example: '#include <complex.h>\nfloat _Complex z = 0.5f + 0.0f*I; float _Complex w = cacosf(z);' },
  { token: 'cacosh', type: 'identifier', description: 'Complex inverse hyperbolic cosine for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex w = cacosh(1.0 + 2.0*I);' },
  { token: 'cacoshf', type: 'identifier', description: '`float _Complex` version of `cacosh`.', example: '#include <complex.h>\nfloat _Complex w = cacoshf(1.0f + 0.5f*I);' },
  { token: 'cacoshl', type: 'identifier', description: '`long double _Complex` version of `cacosh`.', example: '#include <complex.h>\nlong double _Complex w = cacoshl(1.0L + 1.0L*I);' },
  { token: 'cacosl', type: 'identifier', description: '`long double _Complex` version of `cacos`.', example: '#include <complex.h>\nlong double _Complex z = 1.0L + 0.0L*I; long double _Complex w = cacosl(z);' },
  { token: 'call_once', type: 'identifier', description: '', example: '#include <threads.h>\nvoid init(void) { /* one-time init */ }\nonce_flag flag = ONCE_FLAG_INIT;\ncall_once(&flag, init);' },
  { token: 'calloc', type: 'identifier', description: 'Allocates zero-initialized storage for an array (`nmemb * size`). Returns `NULL` on failure; beware multiplication overflow.', example: '#include <stdlib.h>\nint *p = calloc(10, sizeof *p);' },
  { token: 'carg', type: 'identifier', description: 'Argument (phase angle) of a `double _Complex` number, in radians.', example: '#include <complex.h>\ndouble _Complex z = -1.0 + 0.0*I; double a = carg(z); // ~pi' },
  { token: 'cargf', type: 'identifier', description: '`float _Complex` version of `carg`.', example: '#include <complex.h>\nfloat _Complex z = 1.0f + 1.0f*I; float a = cargf(z);' },
  { token: 'cargl', type: 'identifier', description: '`long double _Complex` version of `carg`.', example: '#include <complex.h>\nlong double _Complex z = 1.0L - 1.0L*I; long double a = cargl(z);' },
  { token: 'case', type: 'identifier', description: 'Labels a branch inside a `switch` statement for a matching constant expression value. Must be used within `switch`.', example: 'int n = 2;\nswitch (n) {\n    case 1: /* ... */ break;\n    case 2: /* ... */ break;\n    default: /* ... */ break;\n}' },
  { token: 'casin', type: 'identifier', description: 'Complex arc sine for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex w = casin(0.5 + 0.5*I);' },
  { token: 'casinf', type: 'identifier', description: '`float _Complex` version of `casin`.', example: '#include <complex.h>\nfloat _Complex w = casinf(0.5f + 0.0f*I);' },
  { token: 'casinh', type: 'identifier', description: 'Complex inverse hyperbolic sine for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex w = casinh(1.0 + 1.0*I);' },
  { token: 'casinhf', type: 'identifier', description: 'Complex inverse hyperbolic sine for `float _Complex`.', example: '#include <complex.h>\nfloat _Complex z = 1.0f + 2.0f * I;\nfloat _Complex r = casinhf(z);\n// r holds asinh(z) in complex plane' },
  { token: 'casinl', type: 'identifier', description: '`long double _Complex` version of `casin`.', example: '#include <complex.h>\nlong double _Complex w = casinl(0.0L + 1.0L*I);' },
  { token: 'catan', type: 'identifier', description: 'Complex arc tangent for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex z = 1.0 + 2.0 * I;\ndouble _Complex r = catan(z);\n// r is atan(z) (principal value)' },
  { token: 'catanf', type: 'identifier', description: '`float _Complex` version of `catan`.', example: '#include <complex.h>\nfloat _Complex z = 1.0f + 2.0f * I;\nfloat _Complex r = catanf(z);\n// r is atan(z) for float complex' },
  { token: 'catanh', type: 'identifier', description: 'Complex inverse hyperbolic tangent for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex z = 1.0 + 2.0 * I;\ndouble _Complex r = catanh(z);\n// r is atanh(z)' },
  { token: 'catanhf', type: 'identifier', description: '`float _Complex` version of `catanh`.', example: '#include <complex.h>\nfloat _Complex z = 1.0f + 2.0f * I;\nfloat _Complex r = catanhf(z);' },
  { token: 'catanl', type: 'identifier', description: '`long double _Complex` version of `catan`.', example: '#include <complex.h>\nlong double _Complex z = 1.0L + 2.0L * I;\nlong double _Complex r = catanl(z);' },
  { token: 'cbrt', type: 'identifier', description: 'Cube root for `double`.', example: '#include <math.h>\ndouble r = cbrt(27.0);\n// r == 3.0' },
  { token: 'cbrtf', type: 'identifier', description: '`float` version of `cbrt`.', example: '#include <math.h>\nfloat r = cbrtf(27.0f);' },
  { token: 'cbrtl', type: 'identifier', description: '`long double` version of `cbrt`.', example: '#include <math.h>\nlong double r = cbrtl(27.0L);' },
  { token: 'ccos', type: 'identifier', description: 'Complex cosine for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex z = 1.0 + 2.0*I;\ndouble _Complex r = ccos(z);' },
  { token: 'ccosf', type: 'identifier', description: '`float _Complex` version of `ccos`.', example: '#include <complex.h>\nfloat _Complex z = 1.0f + 2.0f*I;\nfloat _Complex r = ccosf(z);' },
  { token: 'ccosh', type: 'identifier', description: 'Complex hyperbolic cosine for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex r = ccosh(1.0 + 0.5*I);' },
  { token: 'ccoshf', type: 'identifier', description: '`float _Complex` version of `ccosh`.', example: '#include <complex.h>\nfloat _Complex r = ccoshf(1.0f + 0.5f*I);' },
  { token: 'ccosl', type: 'identifier', description: '`long double _Complex` version of `ccos`.', example: '#include <complex.h>\nlong double _Complex z = 1.0L + 2.0L*I;\nlong double _Complex r = ccosl(z);' },
  { token: 'cexp', type: 'identifier', description: 'Complex exponential for `double _Complex`: computes e^z.', example: '#include <complex.h>\ndouble _Complex z = I * 3.141592653589793/2;\ndouble _Complex r = cexp(z);\n// r ≈ 0.0 + 1.0i' },
  { token: 'cexpf', type: 'identifier', description: '`float _Complex` version of `cexp`.', example: '#include <complex.h>\nfloat _Complex r = cexpf(0.0f + I*0.0f);\n// r == 1.0f + 0.0fi' },
  { token: 'cexpl', type: 'identifier', description: '`long double _Complex` version of `cexp`.', example: '#include <complex.h>\nlong double _Complex r = cexplo(0.0L + I*0.0L);\n// r == 1.0L + 0.0Li' },
  { token: 'char', type: 'identifier', description: 'Integer type typically used to store character codes. Signedness is implementation-defined (`char` may be signed or unsigned). `signed char` and `unsigned char` are distinct types.', example: 'char letter = \'A\';' },
  { token: 'CHAR_BIT', type: 'identifier', description: '', example: '#include <limits.h>\nint n = CHAR_BIT; // e.g., 8' },
  { token: 'CHAR_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nint m = CHAR_MAX; // implementation-defined' },
  { token: 'CHAR_MIN', type: 'identifier', description: '', example: '#include <limits.h>\nint m = CHAR_MIN; // implementation-defined' },
  { token: 'cimag', type: 'identifier', description: 'Imaginary part extractor for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex z = 2.0 + 3.0*I;\ndouble im = cimag(z); // 3.0' },
  { token: 'cimagf', type: 'identifier', description: '`float _Complex` version of `cimag`.', example: '#include <complex.h>\nfloat _Complex z = 2.0f + 3.0f*I;\nfloat im = cimagf(z); // 3.0f' },
  { token: 'cimagl', type: 'identifier', description: '`long double _Complex` version of `cimag`.', example: '#include <complex.h>\nlong double _Complex z = 2.0L + 3.0L*I;\nlong double im = cimagl(z); // 3.0L' },
  { token: 'cnd_broadcast', type: 'identifier', description: '', example: '#include <threads.h>\ncnd_t cv; /* initialized */\ncnd_broadcast(&cv);' },
  { token: 'cnd_destroy', type: 'identifier', description: '', example: '#include <threads.h>\ncnd_t cv; /* initialized */\ncnd_destroy(&cv);' },
  { token: 'cnd_init', type: 'identifier', description: '', example: '#include <threads.h>\ncnd_t cv; int r = cnd_init(&cv); // r == thrd_success' },
  { token: 'cnd_signal', type: 'identifier', description: '', example: '#include <threads.h>\ncnd_t cv; /* initialized */\ncnd_signal(&cv);' },
  { token: 'cnd_t', type: 'identifier', description: '', example: '#include <threads.h>\ncnd_t cv;' },
  { token: 'cnd_timedwait', type: 'identifier', description: '', example: '#include <threads.h>\nstruct timespec ts = { .tv_sec = 1, .tv_nsec = 0 };\ncnd_t cv; mtx_t m; /* initialized */\nmtx_lock(&m);\nint r = cnd_timedwait(&cv, &m, &ts);\nmtx_unlock(&m);' },
  { token: 'cnd_wait', type: 'identifier', description: '', example: '#include <threads.h>\ncnd_t cv; mtx_t m; /* initialized */\nmtx_lock(&m);\ncnd_wait(&cv, &m);\nmtx_unlock(&m);' },
  { token: 'conj', type: 'identifier', description: 'Complex conjugate of `double _Complex`.', example: '#include <complex.h>\ndouble _Complex z = 1.0 + 2.0*I;\ndouble _Complex r = conj(z); // 1.0 - 2.0i' },
  { token: 'conjf', type: 'identifier', description: '`float _Complex` version of `conj`.', example: '#include <complex.h>\nfloat _Complex z = 1.0f + 2.0f*I;\nfloat _Complex r = conjf(z); // 1.0f - 2.0fi' },
  { token: 'conjl', type: 'identifier', description: '`long double _Complex` version of `conj`.', example: '#include <complex.h>\nlong double _Complex z = 1.0L + 2.0L*I;\nlong double _Complex r = conjl(z); // 1.0L - 2.0Li' },
  { token: 'const', type: 'identifier', description: 'Qualifies an object or pointer target as read-only. Attempts to modify a `const` object result in undefined behavior. Does not imply static storage.', example: 'const int limit = 10;  /* cannot be modified */' },
  { token: 'continue', type: 'identifier', description: 'Skips to the next iteration of the nearest enclosing loop. In `for` loops, the increment expression is evaluated before the next condition check.', example: 'for (int i = 0; i < 5; i++) {\n    if (i == 2) continue;  // skip printing 2\n}' },
  { token: 'copysign', type: 'identifier', description: 'Returns a value with magnitude of first argument and sign of second.', example: '#include <math.h>\ndouble r = copysign(3.5, -1.0); // -3.5' },
  { token: 'copysignf', type: 'identifier', description: '`float` version of `copysign`.', example: '#include <math.h>\nfloat r = copysignf(2.0f, -0.0f); // -2.0f' },
  { token: 'copysignl', type: 'identifier', description: '`long double` version of `copysign`.', example: '#include <math.h>\nlong double r = copysignl(2.0L, -0.0L); // -2.0L' },
  { token: 'cos', type: 'identifier', description: 'Cosine of an angle in radians (`double`).', example: '#include <math.h>\ndouble r = cos(0.0); // 1.0' },
  { token: 'cosf', type: 'identifier', description: '`float` version of `cos`.', example: '#include <math.h>\nfloat r = cosf(0.0f); // 1.0f' },
  { token: 'cosh', type: 'identifier', description: 'Hyperbolic cosine (`double`).', example: '#include <math.h>\ndouble r = cosh(0.0); // 1.0' },
  { token: 'coshf', type: 'identifier', description: '`float` version of `cosh`.', example: '#include <math.h>\nfloat r = coshf(0.0f); // 1.0f' },
  { token: 'coshl', type: 'identifier', description: '`long double` version of `cosh`.', example: '#include <math.h>\nlong double r = coshl(0.0L); // 1.0L' },
  { token: 'cosl', type: 'identifier', description: '`long double` version of `cos`.', example: '#include <math.h>\nlong double r = cosl(0.0L); // 1.0L' },
  { token: 'cpow', type: 'identifier', description: 'Complex power: raises `double _Complex` base to `double _Complex` exponent.', example: '#include <complex.h>\ndouble _Complex r = cpow(2.0 + 0.0*I, 3.0 + 0.0*I); // 8.0 + 0.0i' },
  { token: 'cpowf', type: 'identifier', description: '`float _Complex` version of `cpow`.', example: '#include <complex.h>\nfloat _Complex r = cpowf(2.0f + 0.0f*I, 3.0f + 0.0f*I); // 8.0f + 0.0fi' },
  { token: 'cpowl', type: 'identifier', description: '`long double _Complex` version of `cpow`.', example: '#include <complex.h>\nlong double _Complex r = cpowl(2.0L + 0.0L*I, 3.0L + 0.0L*I); // 8.0L + 0.0Li' },
  { token: 'cproj', type: 'identifier', description: 'Complex projection: maps finite values to themselves; maps infinities to a point on the Riemann sphere.', example: '#include <complex.h>\ndouble _Complex r = cproj(INFINITY + INFINITY*I);\n// r is infinite on the real axis, imag == copysign(0.0, cimag)' },
  { token: 'cprojf', type: 'identifier', description: '`float _Complex` version of `cproj`.', example: '#include <complex.h>\nfloat _Complex r = cprojf(INFINITY + INFINITY*I);' },
  { token: 'cprojl', type: 'identifier', description: '`long double _Complex` version of `cproj`.', example: '#include <complex.h>\nlong double _Complex r = cprojl(INFINITY + INFINITY*I);' },
  { token: 'creal', type: 'identifier', description: 'Real part extractor for `double _Complex`.', example: '#include <complex.h>\ndouble _Complex z = 2.0 + 3.0*I;\ndouble re = creal(z); // 2.0' },
  { token: 'crealf', type: 'identifier', description: '`float _Complex` version of `creal`.', example: '#include <complex.h>\nfloat _Complex z = 2.0f + 3.0f*I;\nfloat re = crealf(z); // 2.0f' },
  { token: 'creall', type: 'identifier', description: '`long double _Complex` version of `creal`.', example: '#include <complex.h>\nlong double _Complex z = 2.0L + 3.0L*I;\nlong double re = creall(z); // 2.0L' },
  { token: 'ctime', type: 'identifier', description: 'Converts `time_t` to a human-readable local time string. Returns a pointer to a static buffer (not thread-safe).', example: '#include <time.h>\ntime_t now = time(NULL);\nchar *s = ctime(&now);\n// e.g., s == "Sat Sep 13 05:12:08 2025\\n"' },
  { token: 'DBL_EPSILON', type: 'identifier', description: '', example: '#include <float.h>\ndouble e = DBL_EPSILON; // ~2.220446e-16' },
  { token: 'DBL_MAX', type: 'identifier', description: '', example: '#include <float.h>\ndouble x = DBL_MAX; // ~1.797693e+308' },
  { token: 'DBL_MIN', type: 'identifier', description: '', example: '#include <float.h>\ndouble x = DBL_MIN; // ~2.225074e-308' },
  { token: 'DBL_TRUE_MIN', type: 'identifier', description: '', example: '#include <float.h>\ndouble x = DBL_TRUE_MIN; // ~4.940656e-324' },
  { token: 'default', type: 'identifier', description: 'Specifies the fallback branch in a `switch` when no `case` matches. At most one `default` per `switch`.', example: 'switch (getchar()) {\n    case \'y\': /* ... */ break;\n    case \'n\': /* ... */ break;\n    default:  /* ... */ break;\n}' },
  { token: 'difftime', type: 'identifier', description: 'Returns the difference in seconds between two `time_t` values as `double`.', example: '#include <time.h>\ntime_t start = 1000, end = 1005;\ndouble dt = difftime(end, start); // 5.0' },
  { token: 'div', type: 'identifier', description: 'Integer division producing quotient and remainder for `int`.', example: '#include <stdlib.h>\ndiv_t r = div(10, 3);\n// r.quot == 3, r.rem == 1' },
  { token: 'div_t', type: 'identifier', description: 'Result type returned by `div`, with members `int quot; int rem;`.', example: '#include <stdlib.h>\ndiv_t r = div(7, -3);\n// r.quot == -2, r.rem == 1' },
  { token: 'do', type: 'identifier', description: 'Starts a `do`-`while` loop, which executes the body at least once before testing the condition.', example: 'int i = 0;\ndo {\n    /* body */\n    i++;\n} while (i < 5);' },
  { token: 'double', type: 'identifier', description: 'Double-precision floating-point type. `long double` may offer greater precision; `float` offers less.', example: 'double pi = 3.141592653589793;' },
  { token: 'double_t', type: 'identifier', description: 'Floating type from `<math.h>` used for efficient double-precision evaluation (typically an alias of `double`).', example: '#include <math.h>\ndouble_t y = 0.0; // usually the same representation as double' },
  { token: 'EDOM', type: 'identifier', description: '', example: '#include <math.h>\n#include <errno.h>\nerrno = 0; acos(2.0); int e = errno; // e may be set to EDOM' },
  { token: 'EILSEQ', type: 'identifier', description: '', example: '#include <stdlib.h>\n#include <errno.h>\nerrno = 0; mbtowc(NULL, "\\xff", 1); int e = errno; // e may be EILSEQ' },
  { token: 'else', type: 'identifier', description: 'Introduces the alternative branch of an `if` statement when the condition is false. Pairs with the nearest unmatched `if`.', example: 'int x = 3;\nif (x > 0) {\n    /* ... */\n} else {\n    /* ... */\n}' },
  { token: 'enum', type: 'identifier', description: 'Defines an enumeration type with named integer constants. Enumerator values are `int` compatible and may be explicitly assigned.', example: 'enum Color { RED = 0, GREEN = 1, BLUE = 2 };\nenum Color c = GREEN;' },
  { token: 'ERANGE', type: 'identifier', description: '', example: '#include <stdlib.h>\n#include <errno.h>\nerrno = 0; strtod("1e5000", NULL); int e = errno; // e may be ERANGE' },
  { token: 'erf', type: 'identifier', description: 'Error function of a real `double` argument.', example: '#include <math.h>\ndouble v = erf(1.0); // ≈ 0.842701' },
  { token: 'erfc', type: 'identifier', description: 'Complementary error function: `1 - erf(x)` for `double`.', example: '#include <math.h>\ndouble v = erfc(1.0); // ≈ 0.157299' },
  { token: 'erfcf', type: 'identifier', description: '`float` version of `erfc`.', example: '#include <math.h>\nfloat v = erfcf(1.0f); // ≈ 0.157299f' },
  { token: 'erfcl', type: 'identifier', description: '`long double` version of `erfc`.', example: '#include <math.h>\nlong double v = erfcl(1.0L); // ≈ 0.157299L' },
  { token: 'erff', type: 'identifier', description: '`float` error function.', example: '#include <math.h>\nfloat v = erff(1.0f); // ≈ 0.842701f' },
  { token: 'erfl', type: 'identifier', description: '`long double` error function.', example: '#include <math.h>\nlong double v = erfl(1.0L); // ≈ 0.842701L' },
  { token: 'errno', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <errno.h>\nFILE *f = fopen("/nope", "r");\nif (!f) { int e = errno; /* use e */ }' },
  { token: 'exit', type: 'identifier', description: '' },
  { token: 'exp', type: 'identifier', description: 'Natural exponential e^x for `double`.', example: '#include <math.h>\ndouble v = exp(2.0); // ≈ 7.389056' },
  { token: 'exp2', type: 'identifier', description: 'Base-2 exponential 2^x for `double`.', example: '#include <math.h>\ndouble v = exp2(3.0); // 8.0' },
  { token: 'exp2f', type: 'identifier', description: '`float` version of `exp2`.', example: '#include <math.h>\nfloat v = exp2f(3.0f); // 8.0f' },
  { token: 'exp2l', type: 'identifier', description: '`long double` version of `exp2`.', example: '#include <math.h>\nlong double v = exp2l(3.0L); // 8.0L' },
  { token: 'expf', type: 'identifier', description: '`float` exponential e^x.', example: '#include <math.h>\nfloat v = expf(2.0f); // ≈ 7.389056f' },
  { token: 'expl', type: 'identifier', description: '`long double` exponential e^x.', example: '#include <math.h>\nlong double v = expl(2.0L); // ≈ 7.389056L' },
  { token: 'expm1', type: 'identifier', description: 'Computes e^x - 1 with good precision for small x (`double`).', example: '#include <math.h>\ndouble v = expm1(0.1); // ≈ 0.105171' },
  { token: 'expm1f', type: 'identifier', description: '`float` version of `expm1`.', example: '#include <math.h>\nfloat v = expm1f(0.1f); // ≈ 0.105171f' },
  { token: 'expm1l', type: 'identifier', description: '`long double` version of `expm1`.', example: '#include <math.h>\nlong double v = expm1l(0.1L); // ≈ 0.105171L' },
  { token: 'extern', type: 'identifier', description: 'Declares an identifier with external linkage defined elsewhere. Commonly used for variables or functions defined in another translation unit.', example: '/* file1.c */\nint counter = 0;  // definition\n\n/* file2.c */\nextern int counter;  // declaration' },
  { token: 'fabs', type: 'identifier', description: 'Absolute value of a `double`.', example: '#include <math.h>\ndouble v = fabs(-5.5); // 5.5' },
  { token: 'fabsf', type: 'identifier', description: '`float` absolute value.', example: '#include <math.h>\nfloat v = fabsf(-5.5f); // 5.5f' },
  { token: 'fabsl', type: 'identifier', description: '`long double` absolute value.', example: '#include <math.h>\nlong double v = fabsl(-5.5L); // 5.5L' },
  { token: 'fclose', type: 'identifier', description: 'Closes a stream; flushes buffers. Returns 0 on success, EOF on error.', example: '#include <stdio.h>\nFILE *fp = fopen("x.txt", "w");\nint rc = fclose(fp); // 0 on success' },
  { token: 'FE_ALL_EXCEPT', type: 'identifier', description: '', example: '#include <fenv.h>\nfeclearexcept(FE_ALL_EXCEPT);\nint raised = fetestexcept(FE_ALL_EXCEPT); // raised == 0' },
  { token: 'FE_DIVBYZERO', type: 'identifier', description: '', example: '#include <fenv.h>\nint m = FE_DIVBYZERO; // use with fetestexcept(FE_DIVBYZERO)' },
  { token: 'FE_DOWNWARD', type: 'identifier', description: '', example: '#include <fenv.h>\nfesetround(FE_DOWNWARD);' },
  { token: 'FE_INEXACT', type: 'identifier', description: '', example: '#include <fenv.h>\nint m = FE_INEXACT; // use with fetestexcept(FE_INEXACT)' },
  { token: 'FE_INVALID', type: 'identifier', description: '', example: '#include <fenv.h>\nint m = FE_INVALID; // use with fetestexcept(FE_INVALID)' },
  { token: 'FE_OVERFLOW', type: 'identifier', description: '', example: '#include <fenv.h>\nint m = FE_OVERFLOW; // use with fetestexcept(FE_OVERFLOW)' },
  { token: 'FE_TONEAREST', type: 'identifier', description: '', example: '#include <fenv.h>\nfesetround(FE_TONEAREST);' },
  { token: 'FE_TOWARDZERO', type: 'identifier', description: '', example: '#include <fenv.h>\nfesetround(FE_TOWARDZERO);' },
  { token: 'FE_UNDERFLOW', type: 'identifier', description: '', example: '#include <fenv.h>\nint m = FE_UNDERFLOW; // use with fetestexcept(FE_UNDERFLOW)' },
  { token: 'FE_UPWARD', type: 'identifier', description: '', example: '#include <fenv.h>\nfesetround(FE_UPWARD);' },
  { token: 'feclearexcept', type: 'identifier', description: 'Clears the specified floating‑point exception flags given by the bitmask (e.g., `FE_DIVBYZERO`, `FE_INVALID`). Returns 0 on success, nonzero on failure.\n---' },
  { token: 'fegetenv', type: 'identifier', description: 'Stores the current floating‑point environment (rounding mode and exception flags) into a `fenv_t` object. Returns 0 on success.\n---' },
  { token: 'fegetexceptflag', type: 'identifier', description: 'Saves the state of the specified floating‑point exception flags into an `fexcept_t` object for later restoration. Returns 0 on success.\n---' },
  { token: 'fegetround', type: 'identifier', description: 'Gets the current rounding direction, returning one of the macros such as `FE_TONEAREST`, `FE_DOWNWARD`, `FE_UPWARD`, or `FE_TOWARDZERO`.\n---' },
  { token: 'feholdexcept', type: 'identifier', description: 'Saves the current floating‑point environment to a `fenv_t` object, then clears all exception flags and sets a non‑stop mode. Returns 0 on success.\n---' },
  { token: 'fenv_t', type: 'identifier', description: 'Type that represents the entire floating‑point environment (rounding mode and exception flags) used by `<fenv.h>` functions.\n---' },
  { token: 'feof', type: 'identifier', description: 'Tests the end‑of‑file indicator for a stream. Returns nonzero if EOF has been reached; otherwise returns 0.\n---' },
  { token: 'feraiseexcept', type: 'identifier', description: 'Raises (sets) the specified floating‑point exception flags. Returns 0 if all requested exceptions were successfully raised.\n---' },
  { token: 'ferror', type: 'identifier', description: 'Tests the error indicator for a stream. Returns nonzero if a read/write error has occurred on the stream; otherwise returns 0.\n---' },
  { token: 'fesetenv', type: 'identifier', description: 'Installs the floating‑point environment from a `fenv_t` object, replacing the current environment. Returns 0 on success.\n---' },
  { token: 'fesetexceptflag', type: 'identifier', description: 'Sets the state of the specified floating‑point exception flags from an `fexcept_t` object without raising exceptions. Returns 0 on success.\n---' },
  { token: 'fesetround', type: 'identifier', description: 'Sets the current rounding direction to the given macro (e.g., `FE_TONEAREST`, `FE_UPWARD`). Returns 0 on success, nonzero on failure.\n---' },
  { token: 'fetestexcept', type: 'identifier', description: 'Tests which of the specified floating‑point exceptions are currently set and returns a bitwise OR of those flags.\n---' },
  { token: 'feupdateenv', type: 'identifier', description: 'Restores the floating‑point environment from a `fenv_t` object and then raises any exceptions that were set prior to the call. Returns 0 on success.\n---' },
  { token: 'fexcept_t', type: 'identifier', description: 'Type that holds the state of the floating‑point exception flags, used with `fegetexceptflag`/`fesetexceptflag`.\n---' },
  { token: 'fflush', type: 'identifier', description: 'Flushes any buffered output for a stream to its underlying file. If `stream` is `NULL`, all open output streams are flushed. Returns 0 on success, `EOF` on error.\n---' },
  { token: 'fgetc', type: 'identifier', description: 'Reads the next byte from a stream and returns it as an unsigned char cast to int, or `EOF` on end/error.', example: '#include <stdio.h>\n// assume file has "Hello, World\\n"\nFILE *fp = fopen("example.txt", "r");\nint ch = fgetc(fp);\n// ch == \'H\'\nfclose(fp);' },
  { token: 'fgetpos', type: 'identifier', description: 'Stores the current file position in a `fpos_t` object for later restoration with `fsetpos`. Returns 0 on success.', example: '#include <stdio.h>\nFILE *fp = fopen("example.txt", "r");\nfpos_t pos; int rc = fgetpos(fp, &pos); // rc == 0 on success\nfclose(fp);' },
  { token: 'fgets', type: 'identifier', description: 'Reads at most `n-1` chars from stream into buffer, stopping at newline or EOF; writes a terminating `\\0`. Returns `buf` on success or `NULL`.', example: '#include <stdio.h>\n// example.txt: "Hello, World!\\n"\nchar buf[64]; FILE *fp = fopen("example.txt", "r");\nchar *p = fgets(buf, sizeof buf, fp);\n// buf == "Hello, World!\\n"\nfclose(fp);' },
  { token: 'fiprintf', type: 'identifier', description: '' },
  { token: 'float', type: 'identifier', description: 'Single-precision floating-point type.', example: 'float ratio = 0.5f;' },
  { token: 'floor', type: 'identifier', description: 'Largest integer value not greater than `x` (rounded toward −∞).', example: '#include <math.h>\ndouble r = floor(-2.3); // r == -3.0' },
  { token: 'floorf', type: 'identifier', description: '`float` version of `floor`.', example: '#include <math.h>\nfloat r = floorf(2.9f); // r == 2.0f' },
  { token: 'floorl', type: 'identifier', description: '`long double` version of `floor`.', example: '#include <math.h>\nlong double r = floorl(3.0L); // r == 3.0L' },
  { token: 'FLT_EPSILON', type: 'identifier', description: '', example: '#include <float.h>\nfloat e = FLT_EPSILON; // ~1.192093e-07' },
  { token: 'FLT_MAX', type: 'identifier', description: '', example: '#include <float.h>\nfloat x = FLT_MAX; // ~3.402823e+38' },
  { token: 'FLT_MIN', type: 'identifier', description: '', example: '#include <float.h>\nfloat x = FLT_MIN; // ~1.175494e-38 (IEEE-754)' },
  { token: 'FLT_RADIX', type: 'identifier', description: '', example: '#include <float.h>\nint r = FLT_RADIX; // typically 2' },
  { token: 'FLT_TRUE_MIN', type: 'identifier', description: '', example: '#include <float.h>\nfloat x = FLT_TRUE_MIN; // smallest positive float' },
  { token: 'fma', type: 'identifier', description: 'Fused multiply-add: computes `x*y+z` with a single rounding.', example: '#include <math.h>\ndouble r = fma(2.0, 3.0, 4.0); // r == 10.0' },
  { token: 'fmaf', type: 'identifier', description: '`float` version of `fma`.', example: '#include <math.h>\nfloat r = fmaf(1.5f, 2.0f, 1.0f); // r == 4.0f' },
  { token: 'fmal', type: 'identifier', description: '`long double` version of `fma`.', example: '#include <math.h>\nlong double r = fmal(2.0L, 2.5L, 0.5L); // r == 5.5L' },
  { token: 'fmax', type: 'identifier', description: 'Returns the larger of two `double` values; if one operand is NaN, returns the other.', example: '#include <math.h>\ndouble r = fmax(2.0, 3.5); // r == 3.5' },
  { token: 'fmaxf', type: 'identifier', description: '`float` version of `fmax`.', example: '#include <math.h>\nfloat r = fmaxf(-1.0f, -2.0f); // r == -1.0f' },
  { token: 'fmaxl', type: 'identifier', description: '`long double` version of `fmax`.', example: '#include <math.h>\nlong double r = fmaxl(1.0L, 1.0L); // r == 1.0L' },
  { token: 'fmin', type: 'identifier', description: 'Returns the smaller of two `double` values; if one operand is NaN, returns the other.', example: '#include <math.h>\ndouble r = fmin(2.0, 3.5); // r == 2.0' },
  { token: 'fminf', type: 'identifier', description: '`float` version of `fmin`.', example: '#include <math.h>\nfloat r = fminf(-1.0f, -2.0f); // r == -2.0f' },
  { token: 'fminl', type: 'identifier', description: '`long double` version of `fmin`.', example: '#include <math.h>\nlong double r = fminl(1.0L, 1.5L); // r == 1.0L' },
  { token: 'fmod', type: 'identifier', description: 'Floating remainder of `x/y` with the sign of `x`: `x - trunc(x/y)*y`.', example: '#include <math.h>\ndouble r = fmod(7.0, 3.0); // r == 1.0' },
  { token: 'fmodf', type: 'identifier', description: '`float` version of `fmod`.', example: '#include <math.h>\nfloat r = fmodf(7.0f, 2.5f); // r == 2.0f' },
  { token: 'fmodl', type: 'identifier', description: '`long double` version of `fmod`.', example: '#include <math.h>\nlong double r = fmodl(5.0L, 2.0L); // r == 1.0L' },
  { token: 'fopen', type: 'identifier', description: 'Opens a file and associates a stream. Returns `FILE*` or `NULL` on failure. Mode controls read/write/append, text vs binary.', example: '#include <stdio.h>\nFILE *fp = fopen("data.bin", "rb"); // open for reading binary\n// fp != NULL on success\nif (fp) fclose(fp);' },
  { token: 'for', type: 'identifier', description: 'Creates a counted loop with initializer, condition, and iteration expressions. Any component may be omitted; expressions evaluate left-to-right each iteration.', example: 'for (int i = 0; i < 5; i++) {\n    /* body */\n}' },
  { token: 'fprintf', type: 'identifier', description: 'Formatted print to a stream; returns number of characters written or a negative value on error.', example: '#include <stdio.h>\nFILE *fp = fopen("out.txt", "w");\nint n = fprintf(fp, "Name: %s, Age: %d\\n", "Alice", 30);\n// n >= 0, file contains: "Name: Alice, Age: 30\\n"\nfclose(fp);' },
  { token: 'fputc', type: 'identifier', description: 'Writes a byte (unsigned char) to a stream. Returns the written byte or `EOF` on error.', example: '#include <stdio.h>\nFILE *fp = fopen("out.txt", "w");\nint rc = fputc(\'A\', fp); // rc == \'A\'\nfclose(fp);' },
  { token: 'fputs', type: 'identifier', description: 'Writes a string (excluding the terminating `\\0`) to a stream. Returns a nonnegative value on success or `EOF` on error.', example: '#include <stdio.h>\nFILE *fp = fopen("out.txt", "w");\nint rc = fputs("Hello, World!\\n", fp); // rc >= 0; file contains the line\nfclose(fp);' },
  { token: 'fread', type: 'identifier', description: 'Reads up to `count` items of size `size` into `ptr`. Returns the number of items read.', example: '#include <stdio.h>\nchar buf[5]; FILE *fp = fopen("example.txt", "r");\nsize_t n = fread(buf, 1, 5, fp); // n == 5 if 5 bytes available\nfclose(fp);' },
  { token: 'free', type: 'identifier', description: '' },
  { token: 'freopen', type: 'identifier', description: 'Reopens a stream with a new file and mode, reusing the stream object. Commonly used to redirect standard streams.', example: '#include <stdio.h>\nFILE *fp = freopen("out.txt", "w", stdout);\n// stdout now writes to out.txt\nif (fp) fclose(fp);' },
  { token: 'frexp', type: 'identifier', description: 'Decomposes a `double` into mantissa and exponent such that `x = m * 2^exp`, with `m` in [0.5, 1.0).', example: '#include <math.h>\nint e; double m = frexp(8.0, &e); // m == 0.5, e == 4 (0.5*2^4 == 8)' },
  { token: 'frexpf', type: 'identifier', description: '`float` version of `frexp`.', example: '#include <math.h>\nint e; float m = frexpf(3.0f, &e); // m == 0.75f, e == 2 (0.75*2^2 == 3)' },
  { token: 'frexpl', type: 'identifier', description: '`long double` version of `frexp`.', example: '#include <math.h>\nint e; long double m = frexpl(1.0L, &e); // m == 0.5L, e == 1' },
  { token: 'fscanf', type: 'identifier', description: 'Scans formatted input from a stream; returns number of input items assigned, or `EOF` on error/EOF before any assignment.', example: '#include <stdio.h>\nchar name[32]; int age; FILE *fp = fopen("in.txt", "r");\nint n = fscanf(fp, "Name: %31s, Age: %d", name, &age);\n// if file has "Name: Bob, Age: 25", then n == 2, name=="Bob", age==25\nfclose(fp);' },
  { token: 'fseek', type: 'identifier', description: 'Sets the file position indicator relative to `SEEK_SET`, `SEEK_CUR`, or `SEEK_END`. Returns 0 on success.', example: '#include <stdio.h>\nFILE *fp = fopen("example.txt", "r");\nfseek(fp, 5, SEEK_SET);\nint ch = fgetc(fp);\n// If file starts "Hello, World", ch == \',\'\nfclose(fp);' },
  { token: 'fsetpos', type: 'identifier', description: 'Restores a file position saved by `fgetpos`. Returns 0 on success; clears end-of-file indicator.', example: '#include <stdio.h>\nFILE *fp = fopen("example.txt", "r");\nfpos_t pos; fgetpos(fp, &pos);\nint c1 = fgetc(fp); // read one char\nfsetpos(fp, &pos);\nint c2 = fgetc(fp); // c2 == c1\nfclose(fp);' },
  { token: 'ftell', type: 'identifier', description: 'Returns the current file position as a long, or -1L on error.', example: '#include <stdio.h>\nFILE *fp = fopen("example.txt", "r");\nfgetc(fp);\nlong pos = ftell(fp); // 1\nfclose(fp);' },
  { token: 'fwide', type: 'identifier', description: 'Determines or sets the orientation of a stream: returns >0 for wide‑oriented, <0 for byte‑oriented, 0 if undecided. If `mode>0`, attempts to make it wide; if `mode<0`, byte.', example: '#include <wchar.h>\nint o = fwide(stdout, 0); // query orientation; commonly 0 or <0' },
  { token: 'fwprintf', type: 'identifier', description: 'Wide‑character equivalent of `fprintf`; writes formatted wide text to a wide‑oriented stream.', example: '#include <wchar.h>\nint n = fwprintf(stdout, L"Pi ≈ %.2f\\n", 3.14159); // prints wide text' },
  { token: 'fwrite', type: 'identifier', description: 'Writes up to `count` items of size `size` from `ptr` to stream. Returns the number of items written.', example: '#include <stdio.h>\nconst char *s = "ABC";\nFILE *fp = fopen("out.bin", "wb");\nsize_t n = fwrite(s, 1, 3, fp); // n == 3, file gets ABC\nfclose(fp);' },
  { token: 'fwscanf', type: 'identifier', description: 'Wide‑character equivalent of `fscanf`; reads formatted wide text from a wide‑oriented stream.', example: '#include <wchar.h>\n// fwscanf(fp, L"%ls", buf); // reads a wide string' },
  { token: 'getc', type: 'identifier', description: 'Reads the next byte from a stream (often a macro). Returns the byte as unsigned char cast to int, or `EOF`.', example: '#include <stdio.h>\nFILE *fp = fopen("example.txt", "r");\nint ch = getc(fp); // e.g., \'H\'\nfclose(fp);' },
  { token: 'getchar', type: 'identifier', description: 'Reads the next byte from `stdin`. Returns the byte as unsigned char cast to int, or `EOF`.', example: '#include <stdio.h>\n// getchar() waits for input' },
  { token: 'getenv', type: 'identifier', description: 'Returns the value of an environment variable as a C string, or `NULL` if not set. The pointer may be invalidated by subsequent calls that modify the environment.', example: '#include <stdlib.h>\nconst char *p = getenv("HOME"); // e.g., "/Users/alice" or NULL' },
  { token: 'gets', type: 'identifier', description: 'Unsafe input function removed in C11; do not use. Use `fgets` instead.\n---' },
  { token: 'gmtime', type: 'identifier', description: 'Converts `time_t` to broken‑down UTC time in a static `struct tm`. Not thread-safe; use `gmtime_r` where available.', example: '#include <time.h>\ntime_t t = 0; struct tm *tm = gmtime(&t); // tm->tm_year == 70 (1970)' },
  { token: 'goto', type: 'identifier', description: 'Transfers control to a labeled statement within the same function. Use sparingly; you cannot jump into the scope of a variable in a way that skips its initialization.', example: 'int i = 0;\nstart:\nif (++i <= 3) goto start;  // loops 3 times' },
  { token: 'hypot', type: 'identifier', description: 'Computes `sqrt(x*x + y*y)` without undue overflow/underflow.', example: '#include <math.h>\ndouble r = hypot(3.0, 4.0); // r == 5.0' },
  { token: 'hypotf', type: 'identifier', description: '`float` version of `hypot`.', example: '#include <math.h>\nfloat r = hypotf(3.0f, 4.0f); // r == 5.0f' },
  { token: 'hypotl', type: 'identifier', description: '`long double` version of `hypot`.', example: '#include <math.h>\nlong double r = hypotl(3.0L, 4.0L); // r == 5.0L' },
  { token: 'I', type: 'identifier', description: '', example: '#include <complex.h>\ndouble complex z = 0.0 + 1.0*I; // z == i' },
  { token: 'if', type: 'identifier', description: 'Executes a statement/compound-statement conditionally. `else` binds to the nearest unmatched `if`.', example: 'int x = 5;\nif (x > 0) {\n    /* ... */\n} else if (x < 0) {\n    /* ... */\n} else {\n    /* ... */\n}' },
  { token: 'ilogb', type: 'identifier', description: 'Extracts the unbiased exponent of a floating value as an `int` (FP exponent function).', example: '#include <math.h>\nint e = ilogb(8.0); // e == 3 (since 8 == 2^3)' },
  { token: 'ilogbf', type: 'identifier', description: '`float` version of `ilogb`.', example: '#include <math.h>\nint e = ilogbf(0.5f); // e == -1 (0.5 == 2^-1)' },
  { token: 'ilogbl', type: 'identifier', description: '`long double` version of `ilogb`.', example: '#include <math.h>\nint e = ilogbl(1.0L); // e == 0' },
  { token: 'imaxabs', type: 'identifier', description: 'Returns absolute value of a `intmax_t` integer.', example: '#include <inttypes.h>\nintmax_t r = imaxabs((intmax_t)-5); // r == 5' },
  { token: 'imaxdiv', type: 'identifier', description: 'Divides two `intmax_t` values, returning quotient and remainder in `imaxdiv_t`.', example: '#include <inttypes.h>\nimaxdiv_t d = imaxdiv(10, 3); // d.quot == 3, d.rem == 1' },
  { token: 'inline', type: 'identifier', description: 'Suggests that calls to a function be inlined; also affects linkage rules for function definitions in headers. Prefer `static inline` for header-only helpers and provide one external (non-inline) definition if needed.', example: 'static inline int sqr(int x) { return x * x; }' },
  { token: 'int', type: 'identifier', description: 'Signed integer type. Width is implementation-defined (at least 16 bits, commonly 32).', example: 'int count = 42;' },
  { token: 'INT_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nint m = INT_MAX; // e.g., 2147483647 on 32-bit int' },
  { token: 'INT_MIN', type: 'identifier', description: '', example: '#include <limits.h>\nint m = INT_MIN; // e.g., -2147483648 on 32-bit int' },
  { token: 'isalnum', type: 'identifier', description: 'Returns nonzero if the character is alphanumeric (letter or digit). Argument must be `EOF` or `unsigned char` value.', example: '#include <ctype.h>\n#include <stdio.h>\nint r = isalnum(\'A\'); // r != 0' },
  { token: 'isalpha', type: 'identifier', description: 'Returns nonzero if the character is an alphabetic letter. Argument must be `EOF` or `unsigned char` value.', example: '#include <ctype.h>\nint r = isalpha(\'1\'); // r == 0' },
  { token: 'isblank', type: 'identifier', description: 'Returns nonzero if the character is a blank (space or horizontal tab).', example: '#include <ctype.h>\nint r = isblank(\'\\t\'); // r != 0' },
  { token: 'iscntrl', type: 'identifier', description: 'Returns nonzero if the character is a control character.', example: '#include <ctype.h>\nint r = iscntrl(\'\\n\'); // r != 0' },
  { token: 'isdigit', type: 'identifier', description: 'Returns nonzero if the character is a decimal digit (\'0\'..\'9\').', example: '#include <ctype.h>\nint r = isdigit(\'5\'); // r != 0' },
  { token: 'isfinite', type: 'identifier', description: '' },
  { token: 'isgraph', type: 'identifier', description: 'Returns nonzero if the character has a graphical representation (printable and not space).', example: '#include <ctype.h>\nint r = isgraph(\'#\'); // r != 0' },
  { token: 'isgreater', type: 'identifier', description: '' },
  { token: 'isgreaterequal', type: 'identifier', description: '' },
  { token: 'isinf', type: 'identifier', description: '' },
  { token: 'isless', type: 'identifier', description: '' },
  { token: 'islessequal', type: 'identifier', description: '' },
  { token: 'islessgreater', type: 'identifier', description: '' },
  { token: 'islower', type: 'identifier', description: 'Returns nonzero if the character is a lowercase letter.', example: '#include <ctype.h>\nint r = islower(\'g\'); // r != 0' },
  { token: 'isnan', type: 'identifier', description: '' },
  { token: 'isnormal', type: 'identifier', description: '' },
  { token: 'isprint', type: 'identifier', description: 'Returns nonzero if the character is printable (including space).', example: '#include <ctype.h>\nint r = isprint(\' \'); // r != 0' },
  { token: 'ispunct', type: 'identifier', description: 'Returns nonzero if the character is a punctuation character.', example: '#include <ctype.h>\nint r = ispunct(\'!\'); // r != 0' },
  { token: 'isspace', type: 'identifier', description: 'Returns nonzero if the character is whitespace (space, tab, newline, vertical tab, form feed, carriage return).', example: '#include <ctype.h>\nint r = isspace(\'\\n\'); // r != 0' },
  { token: 'isunordered', type: 'identifier', description: '' },
  { token: 'isupper', type: 'identifier', description: 'Returns nonzero if the character is an uppercase letter.', example: '#include <ctype.h>\nint r = isupper(\'Z\'); // r != 0' },
  { token: 'iswalnum', type: 'identifier', description: '', example: '#include <wctype.h>\nint a = iswalnum(L\'A\'); // a != 0\nint b = iswalnum(L\'7\'); // b != 0\nint c = iswalnum(L\'#\'); // c == 0' },
  { token: 'iswalpha', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswalpha(L\'Z\'); // r1 != 0\nint r2 = iswalpha(L\'9\'); // r2 == 0' },
  { token: 'iswblank', type: 'identifier', description: '', example: '#include <wctype.h>\nint s = iswblank(L\' \');  // s != 0\nint t = iswblank(L\'\\t\'); // t != 0\nint n = iswblank(L\'\\n\'); // n == 0' },
  { token: 'iswcntrl', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswcntrl(L\'\\n\'); // r1 != 0\nint r2 = iswcntrl(L\'A\');  // r2 == 0' },
  { token: 'iswctype', type: 'identifier', description: '', example: '#include <wctype.h>\nwctype_t digit_class = wctype("digit");\nint r1 = iswctype(L\'5\', digit_class); // r1 != 0\nint r2 = iswctype(L\'G\', digit_class); // r2 == 0' },
  { token: 'iswdigit', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswdigit(L\'3\'); // r1 != 0\nint r2 = iswdigit(L\'A\'); // r2 == 0' },
  { token: 'iswgraph', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswgraph(L\'!\'); // r1 != 0\nint r2 = iswgraph(L\' \'); // r2 == 0' },
  { token: 'iswlower', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswlower(L\'a\'); // r1 != 0\nint r2 = iswlower(L\'A\'); // r2 == 0' },
  { token: 'iswprint', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswprint(L\' \');  // r1 != 0\nint r2 = iswprint(L\'\\n\'); // r2 == 0' },
  { token: 'iswpunct', type: 'identifier', description: '', example: '#include <wctype.h>\nint r = iswpunct(L\'!\'); // r != 0' },
  { token: 'iswspace', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswspace(L\'\\t\'); // r1 != 0\nint r2 = iswspace(L\'A\');  // r2 == 0' },
  { token: 'iswupper', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswupper(L\'Z\'); // r1 != 0\nint r2 = iswupper(L\'z\'); // r2 == 0' },
  { token: 'iswxdigit', type: 'identifier', description: '', example: '#include <wctype.h>\nint r1 = iswxdigit(L\'B\'); // r1 != 0\nint r2 = iswxdigit(L\'G\'); // r2 == 0' },
  { token: 'isxdigit', type: 'identifier', description: 'Returns nonzero if the character is a hexadecimal digit (\'0\'..\'9\', \'a\'..\'f\', \'A\'..\'F\').', example: '#include <ctype.h>\nint r = isxdigit(\'B\'); // r != 0' },
  { token: 'labs', type: 'identifier', description: '', example: '#include <stdlib.h>\nlong int r = labs(-123L); // r == 123' },
  { token: 'LDBL_EPSILON', type: 'identifier', description: '', example: '#include <float.h>\nlong double e = LDBL_EPSILON;' },
  { token: 'LDBL_MAX', type: 'identifier', description: '', example: '#include <float.h>\nlong double x = LDBL_MAX;' },
  { token: 'LDBL_MIN', type: 'identifier', description: '', example: '#include <float.h>\nlong double x = LDBL_MIN;' },
  { token: 'LDBL_TRUE_MIN', type: 'identifier', description: '', example: '#include <float.h>\nlong double x = LDBL_TRUE_MIN;' },
  { token: 'ldexp', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = ldexp(3.0, 4); // r == 48.0' },
  { token: 'ldexpf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = ldexpf(3.0f, 4); // r == 48.0f' },
  { token: 'ldexpl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = ldexpl(3.0L, 4); // r == 48.0L' },
  { token: 'ldiv', type: 'identifier', description: '', example: '#include <stdlib.h>\nldiv_t q = ldiv(10L, 3L); // q.quot == 3, q.rem == 1' },
  { token: 'ldiv_t', type: 'identifier', description: '', example: '#include <stdlib.h>\nldiv_t r = ldiv(42L, 5L); // r.quot == 8, r.rem == 2' },
  { token: 'lgamma', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = lgamma(5.0); // r ~= log(24) ~= 3.17805383' },
  { token: 'lgammaf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = lgammaf(5.0f); // r ~= 3.17805383f' },
  { token: 'lgammal', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = lgammal(5.0L); // r ~= 3.17805383L' },
  { token: 'llabs', type: 'identifier', description: '', example: '#include <stdlib.h>\nlong long r = llabs(-42LL); // r == 42' },
  { token: 'lldiv', type: 'identifier', description: '', example: '#include <stdlib.h>\nlldiv_t q = lldiv(100LL, 9LL); // q.quot == 11, q.rem == 1' },
  { token: 'lldiv_t', type: 'identifier', description: '', example: '#include <stdlib.h>\nlldiv_t r = lldiv(7LL, 3LL); // r.quot == 2, r.rem == 1' },
  { token: 'LLONG_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nlong long m = LLONG_MAX; // 9223372036854775807' },
  { token: 'LLONG_MIN', type: 'identifier', description: '', example: '#include <limits.h>\nlong long m = LLONG_MIN; // -9223372036854775808' },
  { token: 'localeconv', type: 'identifier', description: '', example: '#include <locale.h>\nsetlocale(LC_ALL, "C");\nstruct lconv *lc = localeconv();\n// lc->decimal_point == "."' },
  { token: 'localtime', type: 'identifier', description: '', example: '#include <time.h>\ntime_t t = time(NULL);\nstruct tm *tm = localtime(&t); // tm != NULL' },
  { token: 'log', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = log(2.718281828); // r ~= 1.0' },
  { token: 'log10', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = log10(1000.0); // r == 3.0' },
  { token: 'log10f', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = log10f(1000.0f); // r == 3.0f' },
  { token: 'log10l', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = log10l(1000.0L); // r == 3.0L' },
  { token: 'log1p', type: 'identifier', description: '', example: '#include <math.h>\ndouble r1 = log1p(0.0);          // r1 == 0.0\ndouble r2 = log1p(exp(1.0) - 1); // r2 ~= 1.0' },
  { token: 'log1pf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = log1pf(expf(1.0f) - 1.0f); // r ~= 1.0f' },
  { token: 'log1pl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = log1pl(expl(1.0L) - 1.0L); // r ~= 1.0L' },
  { token: 'log2', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = log2(16.0); // r == 4.0' },
  { token: 'log2f', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = log2f(8.0f); // r == 3.0f' },
  { token: 'log2l', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = log2l(32.0L); // r == 5.0L' },
  { token: 'logb', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = logb(16.0); // r == 4.0' },
  { token: 'logbf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = logbf(0.5f); // r == -1.0f' },
  { token: 'logbl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = logbl(8.0L); // r == 3.0L' },
  { token: 'logf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = logf(2.7182818f); // r ~= 1.0f' },
  { token: 'logl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = logl(1.0L); // r == 0.0L' },
  { token: 'long', type: 'identifier', description: 'Integer type wider than or equal to `int` (at least 32 bits). Width varies by platform/ABI (`long` is 64-bit on LP64, 32-bit on LLP64).', example: 'long total = 0L;' },
  { token: 'LONG_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nlong m = LONG_MAX; // platform-dependent (e.g., 9223372036854775807 on LP64)' },
  { token: 'LONG_MIN', type: 'identifier', description: '', example: '#include <limits.h>\nlong m = LONG_MIN; // platform-dependent (e.g., -9223372036854775808 on LP64)' },
  { token: 'longjmp', type: 'identifier', description: '', example: '#include <setjmp.h>\n#include <stdio.h>\n\njmp_buf env;\n\nvoid f(void) {\n    longjmp(env, 42);\n}\n\nint main(void) {\n    int r = setjmp(env);\n    if (r == 0) {\n        f();\n        return 1; // not reached\n    }\n    printf("Returned via longjmp with %d\\n", r); // r == 42\n    return 0;\n}' },
  { token: 'malloc', type: 'identifier', description: '', example: '#include <stdlib.h>\n#include <stdio.h>\n\nint *p = (int *)malloc(3 * sizeof(int));\nif (p) {\n    p[0] = 10; p[1] = 20; p[2] = 30; // OK\n    printf("%d %d %d\\n", p[0], p[1], p[2]); // 10 20 30\n}\nfree(p);' },
  { token: 'MB_LEN_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nint n = MB_LEN_MAX;' },
  { token: 'mblen', type: 'identifier', description: '', example: '#include <stdlib.h>\nint r1 = mblen("A", MB_CUR_MAX); // r1 == 1\nint r2 = mblen("\\0", MB_CUR_MAX); // r2 == 0' },
  { token: 'mbrlen', type: 'identifier', description: '', example: '#include <wchar.h>\nmbstate_t st = {0};\nsize_t n = mbrlen("A", MB_CUR_MAX, &st); // n == 1' },
  { token: 'mbrtoc16', type: 'identifier', description: '', example: '#include <uchar.h>\n#include <wchar.h>\nmbstate_t st = {0};\nchar16_t out;\nsize_t n = mbrtoc16(&out, "A", MB_CUR_MAX, &st); // n == 1, out == u\'A\'' },
  { token: 'mbrtoc32', type: 'identifier', description: '', example: '#include <uchar.h>\n#include <wchar.h>\nmbstate_t st = {0};\nchar32_t out;\nsize_t n = mbrtoc32(&out, "A", MB_CUR_MAX, &st); // n == 1, out == U\'A\'' },
  { token: 'mbrtowc', type: 'identifier', description: '', example: '#include <wchar.h>\nmbstate_t st = {0};\nwchar_t wc;\nsize_t n = mbrtowc(&wc, "A", MB_CUR_MAX, &st); // n == 1, wc == L\'A\'' },
  { token: 'mbsinit', type: 'identifier', description: '', example: '#include <wchar.h>\nmbstate_t st = {0};\nint r = mbsinit(&st); // r != 0' },
  { token: 'mbsnrtowcs', type: 'identifier', description: '', example: '#include <wchar.h>\nconst char *src = "Hi";\nmbstate_t st = {0};\nwchar_t dst[8];\nsize_t r = mbsnrtowcs(dst, &src, 2, 8, &st); // r == 2' },
  { token: 'mbsrtowcs', type: 'identifier', description: '', example: '#include <wchar.h>\nconst char *src = "Hello";\nmbstate_t st = {0};\nwchar_t dst[16];\nsize_t r = mbsrtowcs(dst, &src, 16, &st); // r == 5' },
  { token: 'mbstowcs', type: 'identifier', description: '', example: '#include <stdlib.h>\nconst char *src = "OK";\nwchar_t dst[8];\nsize_t r = mbstowcs(dst, src, 8); // r == 2' },
  { token: 'mbtowc', type: 'identifier', description: '', example: '#include <stdlib.h>\nwchar_t wc;\nint n = mbtowc(&wc, "A", MB_CUR_MAX); // n == 1, wc == L\'A\'' },
  { token: 'memchr', type: 'identifier', description: '', example: '#include <string.h>\nconst char *s = "hello";\nconst char *p = (const char *)memchr(s, \'e\', 5); // p == &s[1]' },
  { token: 'memcmp', type: 'identifier', description: '', example: '#include <string.h>\nint r1 = memcmp("abc", "abc", 3); // r1 == 0\nint r2 = memcmp("abc", "abd", 3); // r2 < 0' },
  { token: 'memcpy', type: 'identifier', description: '', example: '#include <string.h>\nchar dst[4];\nmemcpy(dst, "abc", 4); // copies \'a\',\'b\',\'c\',\'\\0\'\n// dst now contains "abc"' },
  { token: 'memmove', type: 'identifier', description: '', example: '#include <string.h>\nchar s[] = "abcdef";\nmemmove(s + 2, s, 4); // s becomes "ababcd"' },
  { token: 'memset', type: 'identifier', description: '', example: '#include <string.h>\nchar buf[5];\nmemset(buf, \'*\', 4); buf[4] = \'\\0\';\n// buf contains "****"' },
  { token: 'mktime', type: 'identifier', description: '', example: '#include <time.h>\nstruct tm tm = {0};\ntm.tm_year = 120; // years since 1900 -> 2020\ntm.tm_mon  = 0;   // January\ntm.tm_mday = 1;   // 1st\nmktime(&tm);\nint wday = tm.tm_wday; // wday == 3 (Wednesday)' },
  { token: 'modf', type: 'identifier', description: '', example: '#include <math.h>\ndouble ip;\ndouble frac = modf(3.75, &ip); // ip == 3.0, frac == 0.75' },
  { token: 'modff', type: 'identifier', description: '', example: '#include <math.h>\nfloat ip;\nfloat frac = modff(2.5f, &ip); // ip == 2.0f, frac == 0.5f' },
  { token: 'modfl', type: 'identifier', description: '', example: '#include <math.h>\nlong double ip;\nlong double frac = modfl(1.25L, &ip); // ip == 1.0L, frac == 0.25L' },
  { token: 'mtx_destroy', type: 'identifier', description: '', example: '#include <threads.h>\nmtx_t m; /* initialized earlier */\nmtx_destroy(&m);' },
  { token: 'mtx_init', type: 'identifier', description: '', example: '#include <threads.h>\nmtx_t m;\nint r = mtx_init(&m, mtx_plain); // r == thrd_success' },
  { token: 'mtx_lock', type: 'identifier', description: '', example: '#include <threads.h>\nmtx_t m; /* initialized */\nmtx_lock(&m);\n// critical section\nmtx_unlock(&m);' },
  { token: 'mtx_plain', type: 'identifier', description: '', example: '#include <threads.h>\nint flags = mtx_plain;' },
  { token: 'mtx_recursive', type: 'identifier', description: '', example: '#include <threads.h>\nint flags = mtx_recursive;' },
  { token: 'mtx_t', type: 'identifier', description: '', example: '#include <threads.h>\nmtx_t m;' },
  { token: 'mtx_timed', type: 'identifier', description: '', example: '#include <threads.h>\nint flags = mtx_timed;' },
  { token: 'mtx_timedlock', type: 'identifier', description: '', example: '#include <threads.h>\nstruct timespec ts = { .tv_sec = 1, .tv_nsec = 0 };\nmtx_t m; /* initialized */\nint r = mtx_timedlock(&m, &ts);' },
  { token: 'mtx_trylock', type: 'identifier', description: '', example: '#include <threads.h>\nmtx_t m; /* initialized */\nint r = mtx_trylock(&m);' },
  { token: 'mtx_unlock', type: 'identifier', description: '', example: '#include <threads.h>\nmtx_t m; /* locked earlier */\nmtx_unlock(&m);' },
  { token: 'nan', type: 'identifier', description: '', example: '#include <math.h>\n#include <stdbool.h>\ndouble x = nan(""); // x is NaN\nbool b = (x != x);   // b == true' },
  { token: 'nanf', type: 'identifier', description: '', example: '#include <math.h>\nfloat x = nanf(""); // x is NaN\nint is_nan = (x != x); // is_nan == 1' },
  { token: 'nanl', type: 'identifier', description: '', example: '#include <math.h>\nlong double x = nanl(""); // x is NaN\nint is_nan = (x != x);     // is_nan == 1' },
  { token: 'nearbyint', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = nearbyint(2.5); // with ties-to-even, r == 2.0' },
  { token: 'nearbyintf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = nearbyintf(3.5f); // with ties-to-even, r == 4.0f' },
  { token: 'nearbyintl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = nearbyintl(1.5L); // with ties-to-even, r == 2.0L' },
  { token: 'nextafter', type: 'identifier', description: '', example: '#include <math.h>\ndouble y = nextafter(1.0, 2.0); // y > 1.0 by the smallest possible increment' },
  { token: 'nextafterf', type: 'identifier', description: '', example: '#include <math.h>\nfloat y = nextafterf(1.0f, 0.0f); // y < 1.0f by the smallest decrement' },
  { token: 'nextafterl', type: 'identifier', description: '', example: '#include <math.h>\nlong double y = nextafterl(0.0L, 1.0L); // y > 0.0L by the smallest increment' },
  { token: 'nexttoward', type: 'identifier', description: '', example: '#include <math.h>\ndouble y = nexttoward(1.0, 2.0L); // moves one ULP toward 2.0' },
  { token: 'nexttowardf', type: 'identifier', description: '', example: '#include <math.h>\nfloat y = nexttowardf(0.0f, 1.0L); // moves one ULP toward 1.0' },
  { token: 'nexttowardl', type: 'identifier', description: '', example: '#include <math.h>\nlong double y = nexttowardl(1.0L, 0.0L); // moves one ULP toward 0.0' },
  { token: 'once_flag', type: 'identifier', description: '', example: '#include <threads.h>\nonce_flag flag = ONCE_FLAG_INIT;' },
  { token: 'perror', type: 'identifier', description: '', example: '#include <stdio.h>\n\nFILE *f = fopen("/no/such/file.txt", "r");\nif (!f) {\n    perror("fopen"); // e.g., "fopen: No such file or directory"\n}' },
  { token: 'pow', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = pow(2.0, 10.0); // r == 1024.0' },
  { token: 'powf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = powf(3.0f, 3.0f); // r == 27.0f' },
  { token: 'powl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = powl(10.0L, 2.0L); // r == 100.0L' },
  { token: 'PRId16', type: 'identifier', description: '', example: '#include <inttypes.h>\nint16_t v = -1234;\nprintf("%" PRId16 "\\n", v); // prints: -1234' },
  { token: 'PRId32', type: 'identifier', description: '', example: '#include <inttypes.h>\nint32_t v = -42;\nprintf("%" PRId32 "\\n", v); // prints: -42' },
  { token: 'PRId64', type: 'identifier', description: '', example: '#include <inttypes.h>\nint64_t v = -9223372036854775807LL;\nprintf("%" PRId64 "\\n", v);' },
  { token: 'PRId8', type: 'identifier', description: '', example: '#include <inttypes.h>\nint8_t v = -5;\nprintf("%" PRId8 "\\n", v); // prints: -5' },
  { token: 'PRIi16', type: 'identifier', description: '', example: '#include <inttypes.h>\nint16_t v = -1234;\nprintf("%" PRIi16 "\\n", v);' },
  { token: 'PRIi32', type: 'identifier', description: '', example: '#include <inttypes.h>\nint32_t v = -42;\nprintf("%" PRIi32 "\\n", v);' },
  { token: 'PRIi64', type: 'identifier', description: '', example: '#include <inttypes.h>\nint64_t v = -42;\nprintf("%" PRIi64 "\\n", v);' },
  { token: 'PRIi8', type: 'identifier', description: '', example: '#include <inttypes.h>\nint8_t v = -5;\nprintf("%" PRIi8 "\\n", v); // prints: -5' },
  { token: 'printf', type: 'identifier', description: '', example: '#include <stdio.h>\nint n = printf("Hello %d\\n", 42); // prints "Hello 42" and newline; n == 9' },
  { token: 'PRIo16', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint16_t v = 511;\nprintf("%" PRIo16 "\\n", v); // prints: 777' },
  { token: 'PRIo32', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint32_t v = 8;\nprintf("%" PRIo32 "\\n", v); // prints: 10' },
  { token: 'PRIo64', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint64_t v = 64;\nprintf("%" PRIo64 "\\n", v); // prints: 100' },
  { token: 'PRIo8', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint8_t v = 63;\nprintf("%" PRIo8 "\\n", v); // prints: 77' },
  { token: 'PRIu16', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint16_t v = 65535;\nprintf("%" PRIu16 "\\n", v); // prints: 65535' },
  { token: 'PRIu32', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint32_t v = 4294967295u;\nprintf("%" PRIu32 "\\n", v);' },
  { token: 'PRIu64', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint64_t v = 18446744073709551615ull;\nprintf("%" PRIu64 "\\n", v);' },
  { token: 'PRIu8', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint8_t v = 200;\nprintf("%" PRIu8 "\\n", v); // prints: 200' },
  { token: 'PRIx16', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint16_t v = 48879;\nprintf("%" PRIx16 "\\n", v); // prints: beef' },
  { token: 'PRIX16', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint16_t v = 48879;\nprintf("%" PRIX16 "\\n", v); // prints: BEEF' },
  { token: 'PRIx32', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint32_t v = 305419896u;\nprintf("%" PRIx32 "\\n", v); // prints: 12345678' },
  { token: 'PRIX32', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint32_t v = 305419896u;\nprintf("%" PRIX32 "\\n", v); // prints: 12345678 (uppercase letters if any)' },
  { token: 'PRIx64', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint64_t v = 0xFFFFFFFFFFFFFFFFull;\nprintf("%" PRIx64 "\\n", v); // prints: ffffffffffffffff' },
  { token: 'PRIX64', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint64_t v = 0xABCDEF1234567890ull;\nprintf("%" PRIX64 "\\n", v); // prints: ABCDEF1234567890' },
  { token: 'PRIx8', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint8_t v = 255;\nprintf("%" PRIx8 "\\n", v); // prints: ff' },
  { token: 'PRIX8', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint8_t v = 255;\nprintf("%" PRIX8 "\\n", v); // prints: FF' },
  { token: 'putc', type: 'identifier', description: '', example: '#include <stdio.h>\nFILE *f = fopen("out.txt", "w");\nputc(\'A\', f);\nfclose(f); // out.txt now contains "A"' },
  { token: 'putchar', type: 'identifier', description: '', example: '#include <stdio.h>\nputchar(\'A\');\nputchar(\'\\n\'); // outputs: A\\n' },
  { token: 'puts', type: 'identifier', description: '', example: '#include <stdio.h>\nint n = puts("Hello"); // outputs: Hello\\n; n >= 0' },
  { token: 'qsort', type: 'identifier', description: '', example: '#include <stdlib.h>\n#include <stdio.h>\n\nint cmp_ints(const void *a, const void *b) {\n    int ia = *(const int *)a;\n    int ib = *(const int *)b;\n    return (ia > ib) - (ia < ib);\n}\n\nint arr[5] = {3, 1, 4, 1, 5};\nqsort(arr, 5, sizeof(int), cmp_ints);\n// arr is now {1, 1, 3, 4, 5}' },
  { token: 'quick_exit', type: 'identifier', description: '', example: '#include <stdlib.h>\n// at_quick_exit handlers (if any) would run here\nquick_exit(0); // program terminates immediately' },
  { token: 'raise', type: 'identifier', description: '', example: '#include <signal.h>\n#include <stdio.h>\n\nvoid handler(int s) { printf("handled %d\\n", s); }\n\nsignal(SIGINT, handler);\nraise(SIGINT); // prints: handled 2' },
  { token: 'rand', type: 'identifier', description: '', example: '#include <stdlib.h>\nsrand(1234);\nint r = rand(); // r is deterministic given the seed, 0 <= r <= RAND_MAX' },
  { token: 'realloc', type: 'identifier', description: '', example: '#include <stdlib.h>\nint *p = (int *)malloc(2 * sizeof(int));\np[0] = 7; p[1] = 9;\np = (int *)realloc(p, 4 * sizeof(int));\np[2] = 11; p[3] = 13;\n// p now has {7, 9, 11, 13}\nfree(p);' },
  { token: 'register', type: 'identifier', description: 'Obsolete hint to place a variable in a CPU register. Taking the address of a `register` variable is not allowed.', example: 'register int i;' },
  { token: 'remainder', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = remainder(6.0, 4.0); // 6/4=1.5 -> nearest even 2 -> r == -2.0' },
  { token: 'remainderf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = remainderf(5.0f, 2.0f); // 5/2=2.5 -> nearest even 2 -> r == 1.0f' },
  { token: 'remainderl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = remainderl(7.0L, 4.0L); // 7/4=1.75 -> r == -1.0L' },
  { token: 'remove', type: 'identifier', description: '', example: '#include <stdio.h>\nFILE *f = fopen("temp.txt", "w");\nif (f) { fputs("x", f); fclose(f); }\nint r = remove("temp.txt"); // r == 0 on success' },
  { token: 'remquo', type: 'identifier', description: '', example: '#include <math.h>\nint q;\ndouble r = remquo(29.0, 8.0, &q); // r == -3.0; q holds low-order quotient bits' },
  { token: 'remquof', type: 'identifier', description: '', example: '#include <math.h>\nint q;\nfloat r = remquof(10.0f, 4.0f, &q); // r == -2.0f; q stores quotient bits' },
  { token: 'remquol', type: 'identifier', description: '', example: '#include <math.h>\nint q;\nlong double r = remquol(13.0L, 4.0L, &q); // r == 1.0L; q stores quotient bits' },
  { token: 'rename', type: 'identifier', description: '', example: '#include <stdio.h>\nFILE *f = fopen("old.txt", "w"); if (f) { fputs("x", f); fclose(f); }\nint r = rename("old.txt", "new.txt"); // r == 0 on success' },
  { token: 'restrict', type: 'identifier', description: 'Pointer qualifier promising that, for the lifetime of the pointer, the object it points to is accessed only through that pointer (or values derived from it). Enables aliasing optimizations. Applies to pointers only.', example: 'void add_arrays(size_t n, const float *restrict a,\n                const float *restrict b, float *restrict out) {\n    for (size_t i = 0; i < n; i++) out[i] = a[i] + b[i];\n}' },
  { token: 'return', type: 'identifier', description: 'Terminates the current function. In non-`void` functions, `return` must include an expression yielding the result. In `void` functions, `return;` returns no value.', example: 'int add(int a, int b) { return a + b; }' },
  { token: 'rewind', type: 'identifier', description: 'Equivalent to `fseek(stream, 0L, SEEK_SET)` and clears error and EOF indicators.', example: '#include <stdio.h>\nFILE *fp = fopen("example.txt", "r");\nfgetc(fp); rewind(fp);\nint ch = fgetc(fp); // back to first byte\nfclose(fp);' },
  { token: 'scanf', type: 'identifier', description: '', example: '#include <stdio.h>\nint x; char word[16];\n// If user types: 42 hello<Enter>\nint n = scanf("%d %15s", &x, word);\n// n == 2, x == 42, word == "hello"' },
  { token: 'SCHAR_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nint m = SCHAR_MAX; // typically 127' },
  { token: 'SCHAR_MIN', type: 'identifier', description: '', example: '#include <limits.h>\nint m = SCHAR_MIN; // typically -128' },
  { token: 'SCNd16', type: 'identifier', description: '', example: '#include <inttypes.h>\nint16_t v; sscanf("-1234", "%" SCNd16, &v); // v == -1234' },
  { token: 'SCNd32', type: 'identifier', description: '', example: '#include <inttypes.h>\nint32_t v; sscanf("-42", "%" SCNd32, &v); // v == -42' },
  { token: 'SCNd64', type: 'identifier', description: '', example: '#include <inttypes.h>\nint64_t v; sscanf("-9223372036854775807", "%" SCNd64, &v);' },
  { token: 'SCNd8', type: 'identifier', description: '', example: '#include <inttypes.h>\nint8_t v; sscanf("-5", "%" SCNd8, &v); // v == -5' },
  { token: 'SCNi16', type: 'identifier', description: '', example: '#include <inttypes.h>\nint16_t v; sscanf("-1234", "%" SCNi16, &v);' },
  { token: 'SCNi32', type: 'identifier', description: '', example: '#include <inttypes.h>\nint32_t v; sscanf("-42", "%" SCNi32, &v);' },
  { token: 'SCNi64', type: 'identifier', description: '', example: '#include <inttypes.h>\nint64_t v; sscanf("-42", "%" SCNi64, &v);' },
  { token: 'SCNi8', type: 'identifier', description: '', example: '#include <inttypes.h>\nint8_t v; sscanf("-5", "%" SCNi8, &v); // v == -5' },
  { token: 'SCNo16', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint16_t v; sscanf("777", "%" SCNo16, &v); // v == 511' },
  { token: 'SCNo32', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint32_t v; sscanf("10", "%" SCNo32, &v); // v == 8' },
  { token: 'SCNo64', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint64_t v; sscanf("100", "%" SCNo64, &v); // v == 64' },
  { token: 'SCNo8', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint8_t v; sscanf("77", "%" SCNo8, &v); // v == 63' },
  { token: 'SCNu16', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint16_t v; sscanf("65535", "%" SCNu16, &v); // v == 65535' },
  { token: 'SCNu32', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint32_t v; sscanf("4294967295", "%" SCNu32, &v);' },
  { token: 'SCNu64', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint64_t v; sscanf("18446744073709551615", "%" SCNu64, &v);' },
  { token: 'SCNu8', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint8_t v; sscanf("200", "%" SCNu8, &v); // v == 200' },
  { token: 'SCNx16', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint16_t v; sscanf("BEEF", "%" SCNx16, &v); // v == 48879' },
  { token: 'SCNx32', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint32_t v; sscanf("12345678", "%" SCNx32, &v); // v == 0x12345678' },
  { token: 'SCNx64', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint64_t v; sscanf("ABCDEF1234567890", "%" SCNx64, &v); // v == 0xABCDEF1234567890' },
  { token: 'SCNx8', type: 'identifier', description: '', example: '#include <inttypes.h>\nuint8_t v; sscanf("ff", "%" SCNx8, &v); // v == 255' },
  { token: 'setbuf', type: 'identifier', description: '', example: '#include <stdio.h>\nstatic char buf[BUFSIZ];\nsetbuf(stdout, buf); // stdout now uses \'buf\' as its buffer' },
  { token: 'setjmp', type: 'identifier', description: '', example: '#include <setjmp.h>\n#include <stdio.h>\n\njmp_buf env;\n\nint main(void) {\n    int r = setjmp(env);\n    if (r == 0) {\n        // later some function may call longjmp(env, 123);\n        printf("saved env\\n");\n    } else {\n        printf("returned via longjmp with %d\\n", r); // e.g., 123\n    }\n    return 0;\n}' },
  { token: 'setlocale', type: 'identifier', description: '', example: '#include <locale.h>\nconst char *loc = setlocale(LC_ALL, "C"); // loc == "C"' },
  { token: 'setvbuf', type: 'identifier', description: '', example: '#include <stdio.h>\nstatic char buf[1024];\nint r = setvbuf(stdout, buf, _IOLBF, sizeof(buf)); // r == 0' },
  { token: 'short', type: 'identifier', description: '`short int` type, at least 16 bits. May be `signed` or `unsigned`.', example: 'short s = 123;' },
  { token: 'SHRT_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nint m = SHRT_MAX; // typically 32767' },
  { token: 'SHRT_MIN', type: 'identifier', description: '', example: '#include <limits.h>\nint m = SHRT_MIN; // typically -32768' },
  { token: 'sig_atomic_t', type: 'identifier', description: '', example: '#include <signal.h>\nvolatile sig_atomic_t flag = 0;\nvoid handler(int s) { flag = 1; }' },
  { token: 'signal', type: 'identifier', description: '', example: '#include <signal.h>\n#include <stdio.h>\n\nvoid handler(int s) { printf("caught %d\\n", s); }\nvoid (*prev)(int) = signal(SIGINT, handler);\n// raising SIGINT will print: caught 2' },
  { token: 'signed', type: 'identifier', description: 'Type modifier indicating a signed integer type. Default for `char` is implementation-defined; `signed char` and `unsigned char` are distinct types.', example: 'signed int temperature = -5;' },
  { token: 'sin', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = sin(M_PI / 2); // r == 1.0' },
  { token: 'sinf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = sinf((float)M_PI / 2.0f); // r == 1.0f' },
  { token: 'sinh', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = sinh(0.0); // r == 0.0' },
  { token: 'sinhf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = sinhf(1.0f); // r ~= 1.175201f' },
  { token: 'sinhl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = sinhl(1.0L); // r ~= 1.175201L' },
  { token: 'sinl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = sinl(0.0L); // r == 0.0L' },
  { token: 'size_t', type: 'identifier', description: '', example: '#include <stdio.h>\nsize_t n = sizeof(int); // typically 4\nprintf("%zu\\n", n);' },
  { token: 'sizeof', type: 'identifier', description: 'Operator yielding the size in bytes of a type or expression (type `size_t`). Its operand is not evaluated, except when applied to a variable length array type.', example: 'size_t n = sizeof(int);' },
  { token: 'snprintf', type: 'identifier', description: '', example: '#include <stdio.h>\nchar buf[8];\nint n = snprintf(buf, sizeof(buf), "%s %d", "hi", 42);\n// buf == "hi 42\\0" (fits), n == 5' },
  { token: 'sprintf', type: 'identifier', description: '', example: '#include <stdio.h>\nchar buf[16];\nint n = sprintf(buf, "%d-%s", 7, "ok");\n// buf == "7-ok\\0", n == 4' },
  { token: 'sqrt', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = sqrt(9.0); // r == 3.0' },
  { token: 'sqrtf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = sqrtf(2.25f); // r == 1.5f' },
  { token: 'sqrtl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = sqrtl(4.0L); // r == 2.0L' },
  { token: 'srand', type: 'identifier', description: '', example: '#include <stdlib.h>\nsrand(42);\nint r = rand(); // deterministic given seed 42' },
  { token: 'sscanf', type: 'identifier', description: '', example: '#include <stdio.h>\nconst char *s = "42 hello";\nint x; char word[16];\nint n = sscanf(s, "%d %15s", &x, word);\n// n == 2, x == 42, word == "hello"' },
  { token: 'static', type: 'identifier', description: 'At block scope: gives a variable static storage duration (retains value across calls, zero-initialized). At file scope: gives internal linkage (not visible outside the translation unit).', example: 'static int file_private;\n\nvoid counter(void) {\n    static int count;  // persists across calls\n    count++;\n}' },
  { token: 'strcat', type: 'identifier', description: '', example: '#include <string.h>\nchar dest[16] = "Hello";\nstrcat(dest, ", ");\nstrcat(dest, "C");\n// dest == "Hello, C"' },
  { token: 'strchr', type: 'identifier', description: '', example: '#include <string.h>\nconst char *s = "abcdea";\nconst char *p = strchr(s, \'a\'); // p == &s[0]' },
  { token: 'strcmp', type: 'identifier', description: '', example: '#include <string.h>\nint r = strcmp("apple", "banana"); // r < 0' },
  { token: 'strcoll', type: 'identifier', description: '', example: '#include <string.h>\n#include <locale.h>\nsetlocale(LC_COLLATE, "C");\nint r = strcoll("a", "b"); // r < 0 in "C" locale' },
  { token: 'strcpy', type: 'identifier', description: '', example: '#include <string.h>\nchar dest[16];\nstrcpy(dest, "hello");\n// dest == "hello"' },
  { token: 'strcspn', type: 'identifier', description: '', example: '#include <string.h>\nsize_t n = strcspn("hello,world", ",!"); // n == 5' },
  { token: 'strerror', type: 'identifier', description: '', example: '#include <string.h>\nconst char *msg = strerror(2); // e.g., "No such file or directory"' },
  { token: 'strftime', type: 'identifier', description: '', example: '#include <time.h>\n#include <stdio.h>\nchar buf[32];\nstruct tm tm = { .tm_year = 123, .tm_mon = 6, .tm_mday = 4 };\nsize_t n = strftime(buf, sizeof(buf), "%Y-%m-%d", &tm);\n// buf == "2023-07-04", n == 10' },
  { token: 'strlen', type: 'identifier', description: '', example: '#include <string.h>\nsize_t n = strlen("hello"); // n == 5' },
  { token: 'strncat', type: 'identifier', description: '', example: '#include <string.h>\nchar dest[8] = "a";\nstrncat(dest, "bcdef", 3);\n// dest == "abcd"' },
  { token: 'strncmp', type: 'identifier', description: '', example: '#include <string.h>\nint r = strncmp("apple", "application", 5); // r == 0' },
  { token: 'strncpy', type: 'identifier', description: '', example: '#include <string.h>\nchar dest[5];\nstrncpy(dest, "hello", sizeof(dest));\n// dest contains {\'h\',\'e\',\'l\',\'l\',\'o\'} (no extra terminator)' },
  { token: 'strpbrk', type: 'identifier', description: '', example: '#include <string.h>\nconst char *s = "abcdxyz";\nconst char *p = strpbrk(s, "xy"); // p == &s[4]' },
  { token: 'strrchr', type: 'identifier', description: '', example: '#include <string.h>\nconst char *s = "abca";\nconst char *p = strrchr(s, \'a\'); // p == &s[3]' },
  { token: 'strspn', type: 'identifier', description: '', example: '#include <string.h>\nsize_t n = strspn("abc123", "abc"); // n == 3' },
  { token: 'strstr', type: 'identifier', description: '', example: '#include <string.h>\nconst char *h = "Hello, World!";\nconst char *p = strstr(h, "World"); // p == h + 7' },
  { token: 'strtod', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar *end;\ndouble x = strtod("3.14pi", &end); // x == 3.14, *end == \'p\'' },
  { token: 'strtof', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar *end;\nfloat x = strtof("2.5e1x", &end); // x == 25.0f, *end == \'x\'' },
  { token: 'strtoimax', type: 'identifier', description: '', example: '#include <inttypes.h>\nchar *end;\nintmax_t v = strtoimax("-0x2A", &end, 0); // v == -42' },
  { token: 'strtok', type: 'identifier', description: '', example: '#include <string.h>\nchar s[] = "a,b;c";\nchar *tok = strtok(s, ",;"); // tok == "a"\ntok = strtok(NULL, ",;");   // tok == "b"\ntok = strtok(NULL, ",;");   // tok == "c"' },
  { token: 'strtol', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar *end;\nlong v = strtol("1010", &end, 2); // v == 10' },
  { token: 'strtold', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar *end;\nlong double x = strtold("1.25L", &end); // x == 1.25L, *end == \'L\'' },
  { token: 'strtoll', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar *end;\nlong long v = strtoll("-42", &end, 10); // v == -42' },
  { token: 'strtoul', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar *end;\nunsigned long v = strtoul("0xff", &end, 0); // v == 255' },
  { token: 'strtoull', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar *end;\nunsigned long long v = strtoull("077", &end, 0); // v == 63 (octal)' },
  { token: 'strtoumax', type: 'identifier', description: '', example: '#include <inttypes.h>\nchar *end;\nuintmax_t v = strtoumax("18446744073709551615", &end, 10); // max 64-bit' },
  { token: 'struct', type: 'identifier', description: 'Defines a structure type aggregating named members.', example: 'struct Point { int x; int y; };\nstruct Point p = { .x = 1, .y = 2 };' },
  { token: 'strxfrm', type: 'identifier', description: '', example: '#include <string.h>\n#include <locale.h>\nsetlocale(LC_COLLATE, "C");\nchar out[32];\nsize_t n = strxfrm(out, "abc", sizeof(out)); // n == 3, out == "abc"' },
  { token: 'switch', type: 'identifier', description: 'Multi-way branch on an integer-controlled expression. `case` labels must be constant integer expressions and unique; use `break` to avoid fallthrough.', example: 'switch (c) {\n    case \'a\': /* ... */ break;\n    case \'b\': /* ... */ break;\n    default:  /* ... */ break;\n}' },
  { token: 'swprintf', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t wbuf[16];\nint n = swprintf(wbuf, 16, L"%ls %d", L"hi", 7);\n// wbuf == L"hi 7", n == 4' },
  { token: 'swscanf', type: 'identifier', description: '', example: '#include <wchar.h>\nconst wchar_t *ws = L"42 test";\nint x; wchar_t word[8];\nint n = swscanf(ws, L"%d %7ls", &x, word);\n// n == 2, x == 42, word == L"test"' },
  { token: 'system', type: 'identifier', description: '', example: '#include <stdlib.h>\nint r = system("echo hi > sys_out.txt"); // r >= 0 if executed' },
  { token: 'tan', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = tan(M_PI / 4); // r ~= 1.0' },
  { token: 'tanf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = tanf((float)M_PI / 4.0f); // r ~= 1.0f' },
  { token: 'tanh', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = tanh(1.0); // r ~= 0.761594' },
  { token: 'tanhf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = tanhf(1.0f); // r ~= 0.761594f' },
  { token: 'tanhl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = tanhl(1.0L); // r ~= 0.761594L' },
  { token: 'tanl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = tanl(M_PI_4); // r ~= 1.0L' },
  { token: 'tgamma', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = tgamma(6.0); // r == 120.0' },
  { token: 'tgammaf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = tgammaf(5.0f); // r == 24.0f' },
  { token: 'tgammal', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = tgammal(3.0L); // r == 2.0L' },
  { token: 'thrd_busy', type: 'identifier', description: '', example: '#include <threads.h>\nint r = thrd_busy;' },
  { token: 'thrd_create', type: 'identifier', description: '', example: '#include <threads.h>\n#include <stdio.h>\n\nint worker(void *arg) { printf("%s\\n", (const char *)arg); return 0; }\n\nthrd_t t;\nint r = thrd_create(&t, worker, (void *)"hi"); // r == thrd_success\nthrd_join(t, NULL);' },
  { token: 'thrd_current', type: 'identifier', description: '', example: '#include <threads.h>\nthrd_t self = thrd_current();' },
  { token: 'thrd_detach', type: 'identifier', description: '', example: '#include <threads.h>\nthrd_t t; /* created earlier */\nint r = thrd_detach(t); // r == thrd_success' },
  { token: 'thrd_equal', type: 'identifier', description: '', example: '#include <threads.h>\nthrd_t a = thrd_current();\nint same = thrd_equal(a, thrd_current()); // same != 0' },
  { token: 'thrd_error', type: 'identifier', description: '', example: '#include <threads.h>\nint r = thrd_error;' },
  { token: 'thrd_exit', type: 'identifier', description: '', example: '#include <threads.h>\nthrd_exit(0);' },
  { token: 'thrd_join', type: 'identifier', description: '', example: '#include <threads.h>\nint res; thrd_t t; /* created earlier */\nint r = thrd_join(t, &res); // r == thrd_success' },
  { token: 'thrd_nomem', type: 'identifier', description: '', example: '#include <threads.h>\nint r = thrd_nomem;' },
  { token: 'thrd_sleep', type: 'identifier', description: '', example: '#include <threads.h>\nstruct timespec ts = { .tv_sec = 0, .tv_nsec = 1000000 }; // 1ms\nthrd_sleep(&ts, NULL);' },
  { token: 'thrd_start_t', type: 'identifier', description: '', example: '#include <threads.h>\nint fn(void *p) { return 0; }\nthrd_start_t start = fn;' },
  { token: 'thrd_success', type: 'identifier', description: '', example: '#include <threads.h>\nint r = thrd_success; // r == 0' },
  { token: 'thrd_t', type: 'identifier', description: '', example: '#include <threads.h>\nthrd_t t;' },
  { token: 'thrd_timedout', type: 'identifier', description: '', example: '#include <threads.h>\nint r = thrd_timedout;' },
  { token: 'thrd_yield', type: 'identifier', description: '', example: '#include <threads.h>\nthrd_yield();' },
  { token: 'time', type: 'identifier', description: '', example: '#include <time.h>\ntime_t now = time(NULL); // now != (time_t)-1 on success' },
  { token: 'time_t', type: 'identifier', description: '', example: '#include <time.h>\ntime_t t = 0; // represents the Unix epoch (implementation-defined)' },
  { token: 'tmpfile', type: 'identifier', description: '', example: '#include <stdio.h>\nFILE *fp = tmpfile();\n// fp != NULL on success; file is temporary' },
  { token: 'tmpnam', type: 'identifier', description: '', example: '#include <stdio.h>\nchar name[L_tmpnam];\ntmpnam(name); // name now holds a temporary filename' },
  { token: 'tolower', type: 'identifier', description: '', example: '#include <ctype.h>\nint r = tolower(\'G\'); // r == \'g\'' },
  { token: 'toupper', type: 'identifier', description: '', example: '#include <ctype.h>\nint r = toupper(\'b\'); // r == \'B\'' },
  { token: 'towctrans', type: 'identifier', description: '', example: '#include <wctype.h>\nwctrans_t tolower_map = wctrans("tolower");\nwint_t r = towctrans(L\'A\', tolower_map); // r == L\'a\'' },
  { token: 'towlower', type: 'identifier', description: '', example: '#include <wctype.h>\nwint_t r = towlower(L\'Ö\'); // r is lowercase variant in locale if defined' },
  { token: 'towupper', type: 'identifier', description: '', example: '#include <wctype.h>\nwint_t r = towupper(L\'ß\'); // may map to L\'ẞ\' in locales that support it' },
  { token: 'trunc', type: 'identifier', description: '', example: '#include <math.h>\ndouble r = trunc(-3.9); // r == -3.0' },
  { token: 'truncf', type: 'identifier', description: '', example: '#include <math.h>\nfloat r = truncf(2.8f); // r == 2.0f' },
  { token: 'truncl', type: 'identifier', description: '', example: '#include <math.h>\nlong double r = truncl(-1.2L); // r == -1.0L' },
  { token: 'tss_create', type: 'identifier', description: '', example: '#include <threads.h>\ntss_t key;\nint r = tss_create(&key, NULL); // r == thrd_success' },
  { token: 'tss_delete', type: 'identifier', description: '', example: '#include <threads.h>\ntss_t key; /* created earlier */\ntss_delete(key);' },
  { token: 'tss_get', type: 'identifier', description: '', example: '#include <threads.h>\ntss_t key; /* created earlier */\nvoid *p = tss_get(key);' },
  { token: 'tss_set', type: 'identifier', description: '', example: '#include <threads.h>\ntss_t key; /* created earlier */\nint r = tss_set(key, (void*)0x1234);' },
  { token: 'tss_t', type: 'identifier', description: '', example: '#include <threads.h>\ntss_t key;' },
  { token: 'typedef', type: 'identifier', description: 'Creates an alias for a type. Does not create a distinct type.', example: 'typedef unsigned long ulong;' },
  { token: 'UCHAR_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nint m = UCHAR_MAX; // typically 255' },
  { token: 'UINT_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nunsigned int m = UINT_MAX; // e.g., 4294967295u on 32-bit' },
  { token: 'ULLONG_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nunsigned long long m = ULLONG_MAX; // 18446744073709551615ull' },
  { token: 'ULONG_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nunsigned long m = ULONG_MAX; // e.g., 18446744073709551615ul on LP64' },
  { token: 'ungetc', type: 'identifier', description: '', example: '#include <stdio.h>\nFILE *fp = fopen("in.txt", "r");\nint ch = fgetc(fp);\nungetc(ch, fp);\nint again = fgetc(fp); // again == ch' },
  { token: 'ungetwc', type: 'identifier', description: '', example: '#include <wchar.h>\nFILE *fp = fopen("in.txt", "r");\nwint_t wc = fgetwc(fp);\nungetwc(wc, fp);\nwint_t again = fgetwc(fp); // again == wc' },
  { token: 'union', type: 'identifier', description: 'Defines a union type whose members share the same storage. Only the most recently written member has a valid value.', example: 'union U { int i; float f; };\nunion U u; u.i = 42;  // u.f then has indeterminate value' },
  { token: 'unsigned', type: 'identifier', description: 'Type modifier for unsigned integer types (no negative values; modulo arithmetic).', example: 'unsigned int u = 10u;' },
  { token: 'USHRT_MAX', type: 'identifier', description: '', example: '#include <limits.h>\nint m = USHRT_MAX; // typically 65535' },
  { token: 'va_arg', type: 'identifier', description: '', example: '#include <stdarg.h>\nint sum(int count, ...) {\n    va_list ap; va_start(ap, count);\n    int s = 0; for (int i = 0; i < count; i++) s += va_arg(ap, int);\n    va_end(ap); return s;\n}' },
  { token: 'va_copy', type: 'identifier', description: '', example: '#include <stdarg.h>\nvoid f(int n, ...) {\n    va_list ap, ap2; va_start(ap, n); va_copy(ap2, ap);\n    // use ap and ap2\n    va_end(ap2); va_end(ap);\n}' },
  { token: 'va_end', type: 'identifier', description: '', example: '#include <stdarg.h>\nvoid g(int n, ...) {\n    va_list ap; va_start(ap, n);\n    // ...\n    va_end(ap);\n}' },
  { token: 'va_list', type: 'identifier', description: '', example: '#include <stdarg.h>\nva_list ap; // declared for use with varargs' },
  { token: 'va_start', type: 'identifier', description: '', example: '#include <stdarg.h>\nvoid f(int n, ...) {\n    va_list ap; va_start(ap, n);\n    // retrieve args via va_arg\n    va_end(ap);\n}' },
  { token: 'vfprintf', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <stdarg.h>\n\nint logf(FILE *fp, const char *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    int n = vfprintf(fp, fmt, ap);\n    va_end(ap); return n;\n}\n// logf(stdout, "%s %d\\n", "ok", 7); // prints: ok 7' },
  { token: 'vfscanf', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <stdarg.h>\n\nint readf(FILE *fp, const char *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    int n = vfscanf(fp, fmt, ap);\n    va_end(ap); return n;\n}' },
  { token: 'void', type: 'identifier', description: 'Indicates no value (function return type) or an unknown object type (`void *`). Objects of type `void` cannot be declared.', example: 'void log_message(const char *s);\nvoid *p = NULL;' },
  { token: 'volatile', type: 'identifier', description: 'Type qualifier indicating that an object may be changed by factors outside the program. Inhibits certain optimizations. Not a substitute for atomicity or synchronization.', example: 'volatile int flag;' },
  { token: 'vprintf', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <stdarg.h>\n\nvoid vlog(const char *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    vprintf(fmt, ap);\n    va_end(ap);\n}\n// vlog("%d %s\\n", 1, "done"); // prints: 1 done' },
  { token: 'vscanf', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <stdarg.h>\n\nint vscan_wrapper(const char *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    int n = vscanf(fmt, ap);\n    va_end(ap); return n;\n}' },
  { token: 'vsnprintf', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <stdarg.h>\n\nint vfmt(char *buf, size_t size, const char *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    int n = vsnprintf(buf, size, fmt, ap);\n    va_end(ap); return n;\n}' },
  { token: 'vsprintf', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <stdarg.h>\n\nint vfmt2(char *buf, const char *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    int n = vsprintf(buf, fmt, ap);\n    va_end(ap); return n;\n}' },
  { token: 'vsscanf', type: 'identifier', description: '', example: '#include <stdio.h>\n#include <stdarg.h>\n\nint vscan(const char *s, const char *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    int n = vsscanf(s, fmt, ap);\n    va_end(ap); return n;\n}' },
  { token: 'vwprintf', type: 'identifier', description: '', example: '#include <wchar.h>\n#include <stdarg.h>\n\nvoid wlog(const wchar_t *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    vwprintf(fmt, ap);\n    va_end(ap);\n}\n// wlog(L"%ls %d\\n", L"ok", 3); // prints: ok 3' },
  { token: 'vwscanf', type: 'identifier', description: '', example: '#include <wchar.h>\n#include <stdarg.h>\n\nint vwscan(const wchar_t *fmt, ...) {\n    va_list ap; va_start(ap, fmt);\n    int n = vwscanf(fmt, ap);\n    va_end(ap); return n;\n}' },
  { token: 'wcrtomb', type: 'identifier', description: '', example: '#include <wchar.h>\nmbstate_t st = {0};\nchar mb[MB_CUR_MAX];\nsize_t n = wcrtomb(mb, L\'A\', &st); // n == 1, mb[0] == \'A\'' },
  { token: 'wcscat', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t dest[16] = L"Hello";\nwcscat(dest, L", ");\nwcscat(dest, L"C");\n// dest == L"Hello, C"' },
  { token: 'wcschr', type: 'identifier', description: '', example: '#include <wchar.h>\nconst wchar_t *ws = L"abcdea";\nconst wchar_t *p = wcschr(ws, L\'a\'); // p == &ws[0]' },
  { token: 'wcscmp', type: 'identifier', description: '', example: '#include <wchar.h>\nint r = wcscmp(L"apple", L"banana"); // r < 0' },
  { token: 'wcscoll', type: 'identifier', description: '', example: '#include <wchar.h>\n#include <locale.h>\nsetlocale(LC_COLLATE, "C");\nint r = wcscoll(L"a", L"b"); // r < 0 in "C" locale' },
  { token: 'wcscpy', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t dest[8];\nwcscpy(dest, L"hi");\n// dest == L"hi"' },
  { token: 'wcscspn', type: 'identifier', description: '', example: '#include <wchar.h>\nsize_t n = wcscspn(L"hello,world", L",!"); // n == 5' },
  { token: 'wcsftime', type: 'identifier', description: '', example: '#include <wchar.h>\n#include <time.h>\nwchar_t buf[32];\nstruct tm tm = { .tm_year = 123, .tm_mon = 6, .tm_mday = 4 };\nsize_t n = wcsftime(buf, 32, L"%Y-%m-%d", &tm);\n// buf == L"2023-07-04", n == 10' },
  { token: 'wcslen', type: 'identifier', description: '', example: '#include <wchar.h>\nsize_t n = wcslen(L"hello"); // n == 5' },
  { token: 'wcsncat', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t dest[8] = L"a";\nwcsncat(dest, L"bcdef", 3);\n// dest == L"abcd"' },
  { token: 'wcsncmp', type: 'identifier', description: '', example: '#include <wchar.h>\nint r = wcsncmp(L"apple", L"application", 5); // r == 0' },
  { token: 'wcsncpy', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t dest[5];\nwcsncpy(dest, L"hello", 5);\n// dest contains L"hello" (no extra terminator)' },
  { token: 'wcspbrk', type: 'identifier', description: '', example: '#include <wchar.h>\nconst wchar_t *ws = L"abcdxyz";\nconst wchar_t *p = wcspbrk(ws, L"xy"); // p == &ws[4]' },
  { token: 'wcsrchr', type: 'identifier', description: '', example: '#include <wchar.h>\nconst wchar_t *ws = L"abca";\nconst wchar_t *p = wcsrchr(ws, L\'a\'); // p == &ws[3]' },
  { token: 'wcsrtombs', type: 'identifier', description: '', example: '#include <wchar.h>\nmbstate_t st = {0};\nconst wchar_t *src = L"Hi";\nchar dst[8];\nsize_t n = wcsrtombs(dst, &src, sizeof(dst), &st); // n == 2' },
  { token: 'wcsspn', type: 'identifier', description: '', example: '#include <wchar.h>\nsize_t n = wcsspn(L"abc123", L"abc"); // n == 3' },
  { token: 'wcsstr', type: 'identifier', description: '', example: '#include <wchar.h>\nconst wchar_t *h = L"Hello, World!";\nconst wchar_t *p = wcsstr(h, L"World"); // p == h + 7' },
  { token: 'wcstod', type: 'identifier', description: '', example: '#include <wchar.h>\ndouble x = wcstod(L"3.14π", NULL); // x == 3.14' },
  { token: 'wcstof', type: 'identifier', description: '', example: '#include <wchar.h>\nfloat x = wcstof(L"2.5e1x", NULL); // x == 25.0f' },
  { token: 'wcstoimax', type: 'identifier', description: '', example: '#include <wchar.h>\n#include <inttypes.h>\nintmax_t v = wcstoimax(L"-0x2A", NULL, 0); // v == -42' },
  { token: 'wcstok', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t s[] = L"a,b;c";\nwchar_t *ctx;\nwchar_t *tok = wcstok(s, L",;", &ctx); // tok == L"a"\ntok = wcstok(NULL, L",;", &ctx);       // tok == L"b"\ntok = wcstok(NULL, L",;", &ctx);       // tok == L"c"' },
  { token: 'wcstol', type: 'identifier', description: '', example: '#include <wchar.h>\nlong v = wcstol(L"1010", NULL, 2); // v == 10' },
  { token: 'wcstold', type: 'identifier', description: '', example: '#include <wchar.h>\nlong double x = wcstold(L"1.25L", NULL); // x == 1.25L' },
  { token: 'wcstoll', type: 'identifier', description: '', example: '#include <wchar.h>\nlong long v = wcstoll(L"-42", NULL, 10); // v == -42' },
  { token: 'wcstombs', type: 'identifier', description: '', example: '#include <stdlib.h>\n#include <wchar.h>\nchar mb[16];\nsize_t n = wcstombs(mb, L"Hi", sizeof(mb)); // n == 2' },
  { token: 'wcstoul', type: 'identifier', description: '', example: '#include <wchar.h>\nunsigned long v = wcstoul(L"0xff", NULL, 0); // v == 255' },
  { token: 'wcstoull', type: 'identifier', description: '', example: '#include <wchar.h>\nunsigned long long v = wcstoull(L"077", NULL, 0); // v == 63 (octal)' },
  { token: 'wcstoumax', type: 'identifier', description: '', example: '#include <wchar.h>\n#include <inttypes.h>\nuintmax_t v = wcstoumax(L"18446744073709551615", NULL, 10); // max 64-bit' },
  { token: 'wcsxfrm', type: 'identifier', description: '', example: '#include <wchar.h>\n#include <locale.h>\nsetlocale(LC_COLLATE, "C");\nwchar_t out[16];\nsize_t n = wcsxfrm(out, L"abc", 16); // n == 3, out == L"abc"' },
  { token: 'wctob', type: 'identifier', description: '', example: '#include <wchar.h>\nint c = wctob(L\'A\'); // c == \'A\'' },
  { token: 'wctomb', type: 'identifier', description: '', example: '#include <stdlib.h>\nchar mb[MB_CUR_MAX];\nint n = wctomb(mb, L\'A\'); // n == 1, mb[0] == \'A\'' },
  { token: 'wctrans', type: 'identifier', description: '', example: '#include <wctype.h>\nwctrans_t map = wctrans("toupper");\nwint_t r = towctrans(L\'a\', map); // r == L\'A\'' },
  { token: 'wctype', type: 'identifier', description: '', example: '#include <wctype.h>\nwctype_t cls = wctype("digit");\nint r1 = iswctype(L\'5\', cls); // r1 != 0\nint r2 = iswctype(L\'A\', cls); // r2 == 0' },
  { token: 'wcwidth', type: 'identifier', description: '', example: '#include <wchar.h>\nint w = wcwidth(L\'A\'); // w == 1' },
  { token: 'while', type: 'identifier', description: 'Pre-test loop that repeats while the condition is nonzero.', example: 'int i = 0;\nwhile (i < 3) { i++; }' },
  { token: 'wmemchr', type: 'identifier', description: '', example: '#include <wchar.h>\nconst wchar_t *s = L"hello";\nconst wchar_t *p = wmemchr(s, L\'l\', 5); // p == &s[2]' },
  { token: 'wmemcmp', type: 'identifier', description: '', example: '#include <wchar.h>\nint r = wmemcmp(L"abc", L"abd", 3); // r < 0' },
  { token: 'wmemcpy', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t dst[4];\nwmemcpy(dst, L"abc", 4); // copies L\'a\',L\'b\',L\'c\',L\'\\0\'' },
  { token: 'wmemmove', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t s[] = L"abcdef";\nwmemmove(s + 2, s, 4); // s becomes L"ababcd"' },
  { token: 'wmemset', type: 'identifier', description: '', example: '#include <wchar.h>\nwchar_t buf[5];\nwmemset(buf, L\'*\', 4); buf[4] = L\'\\0\';\n// buf == L"****"' },
  { token: 'wprintf', type: 'identifier', description: '', example: '#include <wchar.h>\nint n = wprintf(L"%ls %d\\n", L"hi", 7); // prints: hi 7\\n; n == 5' },
  { token: 'wscanf', type: 'identifier', description: '', example: '#include <wchar.h>\nint x; wchar_t w[8];\n// If user types: 42 test<Enter>\nint n = wscanf(L"%d %7ls", &x, w);\n// n == 2, x == 42, w == L"test"' },
  { token: '{ }', type: 'identifier', description: 'Braces create a compound statement (block) or delimit initializers.', example: 'if (cond) { int t = 0; /* ... */ }\nint a[3] = {1,2,3};' },
  { token: '|', type: 'identifier', description: 'Bitwise OR.', example: 'int r = 5 | 2; // 7' },
  { token: '|=', type: 'identifier', description: 'Bitwise OR assignment.', example: 'x |= 0x10;' },
  { token: '||', type: 'identifier', description: 'Logical OR with short-circuit evaluation. Evaluates right operand only if left is zero.', example: 'if (err || fallback()) { /* ... */ }' },
  { token: '~', type: 'identifier', description: 'Bitwise NOT (ones\' complement) of an integer type.', example: 'unsigned char m = (unsigned char)~0u; // 0xFF on 8-bit char' }
];
